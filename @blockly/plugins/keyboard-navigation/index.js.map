{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:///external {\"root\":\"Blockly\",\"commonjs\":\"blockly/core\",\"commonjs2\":\"blockly/core\",\"amd\":\"blockly/core\"}","webpack:///./src/constants.js","webpack:///./src/flyout_cursor.js","webpack:///./src/line_cursor.js","webpack:///./src/navigation.js","webpack:///./src/gesture_monkey_patch.js","webpack:///./src/navigation_controller.js"],"names":["root","factory","exports","module","require","define","amd","a","i","this","__WEBPACK_EXTERNAL_MODULE__0__","installedModules","__webpack_require__","moduleId","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","STATE","WORKSPACE","FLYOUT","TOOLBOX","SHORTCUT_NAMES","PREVIOUS","NEXT","IN","OUT","INSERT","MARK","DISCONNECT","EXIT","TOGGLE_KEYBOARD_NAV","COPY","CUT","PASTE","DELETE","MOVE_WS_CURSOR_UP","MOVE_WS_CURSOR_DOWN","MOVE_WS_CURSOR_LEFT","MOVE_WS_CURSOR_RIGHT","LOGGING_MSG_TYPE","ERROR","WARN","LOG","super","curNode","getCurNode","newNode","next","setCurNode","prev","registrationType","Type","CURSOR","register","pluginInfo","getNextNode_","validLineNode","getType","types","INPUT","getLocation","targetBlock","validInLineNode","getPreviousNode_","node","isValid","location","type","BLOCK","outputConnection","FIELD","workspaceStates","loggingCallback","WS_MOVE_DISTANCE","MARKER_NAME","DEFAULT_WS_COORDINATE","Coordinate","WS_COORDINATE_ON_DELETE","wsChangeWrapper","workspaceChangeListener","flyoutChangeWrapper","flyoutChangeListener","workspaces","workspace","push","flyout","getFlyout","getMarkerManager","registerMarker","addChangeListener","addFlyout","workspaceIdx","indexOf","getCursor","disableKeyboardAccessibility","splice","unregisterMarker","removeChangeListener","removeFlyout","state","id","getMarker","flyoutWorkspace","getWorkspace","FlyoutCursorClass","getClass","setCursor","e","getById","workspaceId","keyboardAccessibilityMode","handleBlockDeleteByDrag","BLOCK_CHANGE","element","handleBlockMutation","CLICK","handleWorkspaceClick","TOOLBOX_ITEM_SELECT","handleToolboxCategoryClick","BLOCK_CREATE","handleBlockCreate","mainWorkspace","targetWorkspace","autoClose","targetType","block","getBlockById","blockId","handleBlockClickInFlyout","SELECTED","newElementId","getState","resetFlyout","getToolbox","setState","mutatedBlockId","cursor","getSourceBlock","createBlockNode","workspaceState","newItem","focusToolbox","deletedBlockId","ids","sourceBlock","createWorkspaceNode","isShadow","getParent","getFlyoutCursor","createStackNode","deletedBlock","topConnection","previousConnection","createConnectionNode","targetConnection","getRelativeToSurfaceXY","getChildren","toolbox","markAtCursor","getSelectedItem","toolboxItems","getToolboxItems","toolboxItem","isSelectable","selectItemByPosition","topBlocks","getTopBlocks","length","astNode","reset","setCursorOnWorkspaceFocus","wsCoordinates","x","scale","y","createTopNode","wsNode","newBlock","createNewBlock","markerNode","tryToConnectMarkerAndCursor","warn","focusWorkspace","removeMark","isVisible","curBlock","isEnabled","createBlock","render","setConnectionTracking","shouldHide","hide","cursorNode","logConnectionWarning","markerType","cursorType","cursorLoc","markerLoc","isConnection","cursorConnection","markerConnection","connect","STACK","cursorBlock","insertBlock","moveBlockToWorkspace","unplug","moveTo","getWsCoordinate","movingConnection","destConnection","movingBlock","destBlock","inferiorConnection","getRootBlock","getDescendants","getInferiorConnection","disconnect","movingInferior","destSuperior","getSuperiorConnection","movingSuperior","destInferior","moveAndConnect","checker","getConnectionChecker","reason","canConnectWithReason","getErrorMessage","connection","isSuperior","canConnect","disconnectChild","positionNearConnection","nextConnection","inputList","inputConnection","log","curConnection","isConnected","superiorConnection","bumpAwayFrom","bringToFront","connectionNode","marker","msg","console","error","xDirection","yDirection","wsCoord","newX","newY","nodeType","showEditor","isHandled","isFlyout","isCapacityAvailable","setGroup","domToBlock","insertPastedBlock","fire","BlockCreate","markedNode","removeWorkspace","oldDoWorkspaceClick","doWorkspaceClick_","ws","creatorWorkspace_","shiftKey","screenCoord","clientX","clientY","screenToWsCoordinates","oldDoBlockClick","doBlockClick_","targetBlock_","isInFlyout","mostRecentEvent_","optNavigation","navigation","addShortcutHandlers","registerDefaults","onShortcut","fieldColourHandler","fieldDropdownHandler","toolboxHandler","shortcut","picker_","moveHighlightBy_","superClass_","menu_","highlightPrevious","highlightNext","selectedItem_","selectPrevious_","selectParent_","selectNext_","selectChild_","addWorkspace","enableKeyboardAccessibility","previousShortcut","preconditionFn","callback","fieldShortcutHandler","registry","addKeyMapping","KeyCodes","W","toggleKeyboardNavShortcut","ctrlShiftK","createSerializedKey","K","CTRL","SHIFT","outShortcut","out","A","nextShortcut","S","inShortcut","in","focusFlyout","D","insertShortcut","options","readOnly","connectMarkerAndCursor","I","markShortcut","handleEnterForWS","insertFromFlyout","ENTER","disconnectShortcut","disconnectBlocks","X","focusToolboxShortcut","T","exitShortcut","ESC","E","wsMoveLeftShortcut","moveWSCursor","shiftA","wsMoveRightShortcut","shiftD","wsMoveUpShortcut","shiftW","wsMoveDownShortcut","copyShortcut","inProgress","isDeletable","isMovable","ctrlC","C","altC","ALT","metaC","META","pasteShortcut","paste","ctrlV","V","altV","metaV","cutShortcut","moveCursorOnBlockDelete","ctrlX","altX","metaX","deleteShortcut","preventDefault","BACKSPACE","registerPrevious","registerNext","registerIn","registerOut","registerDisconnect","registerExit","registerInsert","registerMark","registerToolboxFocus","registerToggleKeyboardNav","registerWorkspaceMoveDown","registerWorkspaceMoveLeft","registerWorkspaceMoveUp","registerWorkspaceMoveRight","registerCopy","registerPaste","registerCut","registerDelete","shortcutNames","values","unregister","removeShortcutHandlers","dispose"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"blockly/core\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"blockly/core\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"blockly/core\")) : factory(root[\"Blockly\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function(__WEBPACK_EXTERNAL_MODULE__0__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Constants for keyboard navigation.\n * @author aschmiedt@google.com (Abby Schmiedt)\n */\n\n/**\n * Keyboard navigation states.\n * The different parts of Blockly that the user navigates between.\n * @enum {string}\n * @const\n * @public\n */\nexport const STATE = {\n  WORKSPACE: 'workspace',\n  FLYOUT: 'flyout',\n  TOOLBOX: 'toolbox',\n};\n\n/**\n * Default keyboard navigation shortcut names.\n * @enum {string}\n * @const\n * @public\n */\nexport const SHORTCUT_NAMES = {\n  PREVIOUS: 'previous',\n  NEXT: 'next',\n  IN: 'in',\n  OUT: 'out',\n  INSERT: 'insert',\n  MARK: 'mark',\n  DISCONNECT: 'disconnect',\n  TOOLBOX: 'toolbox',\n  EXIT: 'exit',\n  TOGGLE_KEYBOARD_NAV: 'toggle_keyboard_nav',\n  COPY: 'keyboard_nav_copy',\n  CUT: 'keyboard_nav_cut',\n  PASTE: 'keyboard_nav_paste',\n  DELETE: 'keyboard_nav_delete',\n  MOVE_WS_CURSOR_UP: 'workspace_up',\n  MOVE_WS_CURSOR_DOWN: 'workspace_down',\n  MOVE_WS_CURSOR_LEFT: 'workspace_left',\n  MOVE_WS_CURSOR_RIGHT: 'workspace_right',\n};\n\n/**\n * Types of possible messages passed into the loggingCallback in the Navigation\n * class.\n * @enum {string}\n * @const\n * @public\n */\nexport const LOGGING_MSG_TYPE = {\n  ERROR: 'error',\n  WARN: 'warn',\n  LOG: 'log',\n};\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The class representing a cursor used to navigate the flyout.\n * @author aschmiedt@google.com (Abby Schmiedt)\n */\n\nimport * as Blockly from 'blockly/core';\n\n/**\n * Class for a flyout cursor.\n * This controls how a user navigates blocks in the flyout.\n * This cursor only allows a user to go to the previous or next stack.\n * @constructor\n * @extends {Blockly.Cursor}\n */\nexport class FlyoutCursor extends Blockly.Cursor {\n  /**\n   * The constructor for the FlyoutCursor.\n   */\n  constructor() {\n    super();\n  }\n\n  /**\n   * Moves the cursor to the next stack of blocks in the flyout.\n   * @return {Blockly.ASTNode} The next element, or null if the current node is\n   *     not set or there is no next value.\n   * @override\n   */\n  next() {\n    const curNode = this.getCurNode();\n    if (!curNode) {\n      return null;\n    }\n    const newNode = curNode.next();\n\n    if (newNode) {\n      this.setCurNode(newNode);\n    }\n    return newNode;\n  }\n\n  /**\n   * This is a no-op since a flyout cursor can not go in.\n   * @return {null} Always null.\n   * @override\n   */\n  in() {\n    return null;\n  }\n\n  /**\n   * Moves the cursor to the previous stack of blocks in the flyout.\n   * @return {Blockly.ASTNode} The previous element, or null if the current node\n   *     is not set or there is no previous value.\n   * @override\n   */\n  prev() {\n    const curNode = this.getCurNode();\n    if (!curNode) {\n      return null;\n    }\n    const newNode = curNode.prev();\n\n    if (newNode) {\n      this.setCurNode(newNode);\n    }\n    return newNode;\n  }\n\n  /**\n   * This is a  no-op since a flyout cursor can not go out.\n   * @return {null} Always null.\n   * @override\n   */\n  out() {\n    return null;\n  }\n}\n\nexport const registrationType = Blockly.registry.Type.CURSOR;\nexport const registrationName = 'FlyoutCursor';\n\nBlockly.registry.register(registrationType, registrationName, FlyoutCursor);\n\nexport const pluginInfo = {\n  [registrationType]: registrationName,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The class representing a line cursor.\n * A line cursor tries to traverse the blocks and connections on a block as if\n * they were lines of code in a text editor. Previous and next traverse previous\n * connections, next connections and blocks, while in and out traverse input\n * connections and fields.\n * @author aschmiedt@google.com (Abby Schmiedt)\n */\n\nimport * as Blockly from 'blockly/core';\n\n/**\n * Class for a line cursor.\n * @constructor\n * @extends {Blockly.BasicCursor}\n */\nexport class LineCursor extends Blockly.BasicCursor {\n  /**\n   * Constructor for a line cursor.\n   */\n  constructor() {\n    super();\n  }\n\n  /**\n   * Moves the cursor to the next previous connection, next connection or block\n   * in the pre order traversal. Finds the next node in the pre order traversal.\n   * @return {Blockly.ASTNode} The next node, or null if the current node is\n   *     not set or there is no next value.\n   * @override\n   */\n  next() {\n    const curNode = this.getCurNode();\n    if (!curNode) {\n      return null;\n    }\n    let newNode = this.getNextNode_(curNode, this.validLineNode);\n\n    // Skip the input or next value if there is a connected block.\n    if (newNode &&\n        (newNode.getType() == Blockly.ASTNode.types.INPUT ||\n         newNode.getType() == Blockly.ASTNode.types.NEXT) &&\n        newNode.getLocation().targetBlock()) {\n      newNode = this.getNextNode_(newNode, this.validLineNode);\n    }\n    if (newNode) {\n      this.setCurNode(newNode);\n    }\n    return newNode;\n  }\n\n  /**\n   * Moves the cursor to the next input connection or field\n   * in the pre order traversal.\n   * @return {Blockly.ASTNode} The next node, or null if the current node is\n   *     not set or there is no next value.\n   * @override\n   */\n  in() {\n    const curNode = this.getCurNode();\n    if (!curNode) {\n      return null;\n    }\n    const newNode = this.getNextNode_(curNode, this.validInLineNode);\n\n    if (newNode) {\n      this.setCurNode(newNode);\n    }\n    return newNode;\n  }\n  /**\n   * Moves the cursor to the previous next connection or previous connection in\n   * the pre order traversal.\n   * @return {Blockly.ASTNode} The previous node, or null if the current node\n   *     is not set or there is no previous value.\n   * @override\n   */\n  prev() {\n    const curNode = this.getCurNode();\n    if (!curNode) {\n      return null;\n    }\n    let newNode = this.getPreviousNode_(curNode, this.validLineNode);\n\n    if (newNode &&\n        (newNode.getType() == Blockly.ASTNode.types.INPUT ||\n         newNode.getType() == Blockly.ASTNode.types.NEXT) &&\n        newNode.getLocation().targetBlock()) {\n      newNode = this.getPreviousNode_(newNode, this.validLineNode);\n    }\n\n    if (newNode) {\n      this.setCurNode(newNode);\n    }\n    return newNode;\n  }\n  /**\n   * Moves the cursor to the previous input connection or field in the pre order\n   * traversal.\n   * @return {Blockly.ASTNode} The previous node, or null if the current node is\n   *     not set or there is no previous value.\n   * @override\n   */\n  out() {\n    const curNode = this.getCurNode();\n    if (!curNode) {\n      return null;\n    }\n    const newNode = this.getPreviousNode_(curNode, this.validInLineNode);\n\n    if (newNode) {\n      this.setCurNode(newNode);\n    }\n    return newNode;\n  }\n\n  /**\n   * Decides if the previous and next methods should traverse the given node.\n   * The previous and next method only traverse previous connections, next\n   * connections and blocks.\n   * @param {Blockly.ASTNode} node The AST node to check.\n   * @return {boolean} True if the node should be visited, false otherwise.\n   * @protected\n   */\n  validLineNode(node) {\n    if (!node) {\n      return false;\n    }\n    let isValid = false;\n    const location = node.getLocation();\n    const type = node && node.getType();\n    if (type == Blockly.ASTNode.types.BLOCK) {\n      if (location.outputConnection === null) {\n        isValid = true;\n      }\n    } else if (\n      type == Blockly.ASTNode.types.INPUT &&\n        location.type == Blockly.NEXT_STATEMENT) {\n      isValid = true;\n    } else if (type == Blockly.ASTNode.types.NEXT) {\n      isValid = true;\n    }\n    return isValid;\n  }\n\n  /**\n   * Decides if the in and out methods should traverse the given node.\n   * The in and out method only traverse fields and input connections.\n   * @param {Blockly.ASTNode} node The AST node to check whether it is valid.\n   * @return {boolean} True if the node should be visited, false otherwise.\n   * @protected\n   */\n  validInLineNode(node) {\n    if (!node) {\n      return false;\n    }\n    let isValid = false;\n    const location = node.getLocation();\n    const type = node && node.getType();\n    if (type == Blockly.ASTNode.types.FIELD) {\n      isValid = true;\n    } else if (\n      type == Blockly.ASTNode.types.INPUT &&\n        location.type == Blockly.INPUT_VALUE) {\n      isValid = true;\n    }\n    return isValid;\n  }\n}\n\n\nexport const registrationName = 'LineCursor';\nexport const registrationType = Blockly.registry.Type.CURSOR;\n\nBlockly.registry.register(registrationType, registrationName, LineCursor);\n\nexport const pluginInfo = {\n  [registrationType]: registrationName,\n};\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Holds all methods necessary to use Blockly through the\n * keyboard.\n * @author aschmiedt@google.com (Abby Schmiedt)\n */\n\nimport * as Blockly from 'blockly/core';\nimport * as Constants from './constants';\nimport {\n  registrationName as cursorRegistrationName,\n  registrationType as cursorRegistrationType} from './flyout_cursor';\n\n/**\n * Class that holds all methods necessary for keyboard navigation to work.\n */\nexport class Navigation {\n  /**\n   * Constructor for keyboard navigation.\n   */\n  constructor() {\n    /**\n     * Object holding the location of the cursor for each workspace.\n     * Possible locations of the cursor are: workspace, flyout or toolbox.\n     * @type {Object<string,Constants.STATE>}\n     * @protected\n     */\n    this.workspaceStates = {};\n\n    /**\n     * An optional method that allows a developer to customize how to handle\n     * logs, warnings, and errors. The first argument is one of 'log', 'warn',\n     * or 'error'. The second argument is the message.\n     * @type {?function(Constants.LOGGING_MSG_TYPE, string)}\n     * @public\n     */\n    this.loggingCallback = null;\n\n    /**\n     * The distance to move the cursor when the cursor is on the workspace.\n     * @type {number}\n     * @public\n     */\n    this.WS_MOVE_DISTANCE = 40;\n\n    /**\n     * The name of the marker to use for keyboard navigation.\n     * @type {string}\n     * @public\n     */\n    this.MARKER_NAME = 'local_marker_1';\n\n    /**\n     * The default coordinate to use when focusing on the workspace and no\n     * blocks are present. In pixel coordinates, but will be converted to\n     * workspace coordinates when used to position the cursor.\n     * @type {!Blockly.utils.Coordinate}\n     * @public\n     */\n    this.DEFAULT_WS_COORDINATE = new Blockly.utils.Coordinate(100, 100);\n\n    /**\n     * The default coordinate to use when moving the cursor to the workspace\n     * after a block has been deleted. In pixel coordinates, but will be\n     * converted to workspace coordinates when used to position the cursor.\n     * @type {!Blockly.utils.Coordinate}\n     * @public\n     */\n    this.WS_COORDINATE_ON_DELETE = new Blockly.utils.Coordinate(100, 100);\n\n    /**\n     * Wrapper for method that deals with workspace changes.\n     * Used for removing change listener.\n     * @type {Function}\n     * @protected\n     */\n    this.wsChangeWrapper = this.workspaceChangeListener.bind(this);\n\n    /**\n     * Wrapper for method that deals with flyout changes.\n     * Used for removing change listener.\n     * @type {Function}\n     * @protected\n     */\n    this.flyoutChangeWrapper = this.flyoutChangeListener.bind(this);\n\n    /**\n     * The list of registered workspaces.\n     * Used when removing change listeners in dispose.\n     * @type {!Array<!Blockly.WorkspaceSvg>}\n     * @protected\n     */\n    this.workspaces = [];\n  }\n\n  /**\n   * Adds all necessary change listeners and markers to a workspace for keyboard\n   * navigation to work. This must be called for keyboard navigation to work\n   * on a workspace.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace to add keyboard\n   *     navigation to.\n   * @public\n   */\n  addWorkspace(workspace) {\n    this.workspaces.push(workspace);\n    const flyout = workspace.getFlyout();\n    workspace.getMarkerManager().registerMarker(\n        this.MARKER_NAME, new Blockly.Marker());\n    workspace.addChangeListener(this.wsChangeWrapper);\n\n    if (flyout) {\n      this.addFlyout(flyout);\n    }\n  }\n\n  /**\n   * Removes all keyboard navigation change listeners and markers.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace to remove keyboard\n   *     navigation from.\n   * @public\n   */\n  removeWorkspace(workspace) {\n    const workspaceIdx = this.workspaces.indexOf(workspace);\n    const flyout = workspace.getFlyout();\n\n    if (workspace.getCursor()) {\n      this.disableKeyboardAccessibility(workspace);\n    }\n\n    if (workspaceIdx > -1) {\n      this.workspaces.splice(workspaceIdx, 1);\n    }\n    if (workspace.getMarkerManager()) {\n      workspace.getMarkerManager().unregisterMarker(this.MARKER_NAME);\n    }\n    workspace.removeChangeListener(this.wsChangeWrapper);\n\n    if (flyout) {\n      this.removeFlyout(flyout);\n    }\n  }\n\n  /**\n   * Sets the state for the given workspace.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace to set the state on.\n   * @param {!Constants.STATE} state The navigation state.\n   * @protected\n   */\n  setState(workspace, state) {\n    this.workspaceStates[workspace.id] = state;\n  }\n\n  /**\n   * Gets the navigation state of the current workspace.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace to get the state of.\n   * @return {!Constants.STATE} The state of the given workspace.\n   * @package\n   */\n  getState(workspace) {\n    return this.workspaceStates[workspace.id];\n  }\n\n  /**\n   * Gets the marker created for keyboard navigation.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace to get the marker\n   *     from.\n   * @return {?Blockly.Marker} The marker created for keyboard navigation.\n   * @protected\n   */\n  getMarker(workspace) {\n    return workspace.getMarker(this.MARKER_NAME);\n  }\n\n  /**\n   * Adds all event listeners and cursors to the flyout that are needed for\n   * keyboard navigation to work.\n   * @param {!Blockly.IFlyout} flyout The flyout to add a cursor and change\n   *     listeners to.\n   * @protected\n   */\n  addFlyout(flyout) {\n    const flyoutWorkspace = flyout.getWorkspace();\n    flyoutWorkspace.addChangeListener(this.flyoutChangeWrapper);\n    const FlyoutCursorClass = Blockly.registry.getClass(\n        cursorRegistrationType, cursorRegistrationName);\n    flyoutWorkspace.getMarkerManager().setCursor(new FlyoutCursorClass());\n  }\n\n  /**\n   * Removes all change listeners from the flyout that are needed for\n   * keyboard navigation to work.\n   * @param {!Blockly.IFlyout} flyout The flyout to add a cursor and event\n   *     listeners to.\n   * @protected\n   */\n  removeFlyout(flyout) {\n    const flyoutWorkspace = flyout.getWorkspace();\n    flyoutWorkspace.removeChangeListener(this.flyoutChangeWrapper);\n  }\n\n  /**\n   * Updates the state of keyboard navigation and the position of the cursor\n   * based on workspace events.\n   * @param {!Blockly.Events.Abstract} e The Blockly event to process.\n   * @protected\n   */\n  workspaceChangeListener(e) {\n    const workspace = Blockly.Workspace.getById(e.workspaceId);\n    if (!workspace || !workspace.keyboardAccessibilityMode) {\n      return;\n    }\n    switch (e.type) {\n      case Blockly.Events.DELETE:\n        this.handleBlockDeleteByDrag(workspace, e);\n        break;\n      case Blockly.Events.BLOCK_CHANGE:\n        if (e.element === 'mutation') {\n          this.handleBlockMutation(\n              workspace, /** @type {Blockly.Events.BlockChange} */ (e));\n        }\n        break;\n      case Blockly.Events.CLICK:\n        this.handleWorkspaceClick(\n            workspace, /** @type {Blockly.Events.Click} */ (e));\n        break;\n      case Blockly.Events.TOOLBOX_ITEM_SELECT:\n        this.handleToolboxCategoryClick(\n            workspace, /** @type {Blockly.Events.ToolboxItemSelect} */ (e));\n        break;\n      case Blockly.Events.BLOCK_CREATE:\n        this.handleBlockCreate(workspace, e);\n    }\n  }\n\n  /**\n   * Updates the state of keyboard navigation and the position of the cursor\n   * based on events emitted from the flyout's workspace.\n   * @param {!Blockly.Events.Abstract} e The Blockly event to process.\n   * @protected\n   */\n  flyoutChangeListener(e) {\n    const flyoutWorkspace = Blockly.Workspace.getById(e.workspaceId);\n    const mainWorkspace = flyoutWorkspace.targetWorkspace;\n    const flyout = mainWorkspace.getFlyout();\n\n    // This is called for simple toolboxes and for toolboxes that have a flyout\n    // that does not close. Autoclosing flyouts close before we need to focus\n    // the cursor on the block that was clicked.\n    if (mainWorkspace && mainWorkspace.keyboardAccessibilityMode &&\n        !flyout.autoClose) {\n      if ((e.type === Blockly.Events.CLICK && e.targetType === 'block')) {\n        const block = flyoutWorkspace.getBlockById(e.blockId);\n        this.handleBlockClickInFlyout(mainWorkspace, block);\n      } else if (e.type === Blockly.Events.SELECTED) {\n        const block = flyoutWorkspace.getBlockById(e.newElementId);\n        this.handleBlockClickInFlyout(mainWorkspace, block);\n      }\n    }\n  }\n\n  /**\n   * Moves the cursor to the workspace if a block has been dragged from a simple\n   * toolbox. For a category toolbox this is handled in\n   * handleToolboxCategoryClick_.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace the cursor belongs\n   *     to.\n   * @param {!Blockly.Events.Abstract} e The Blockly event to process.\n   * @protected\n   */\n  handleBlockCreate(workspace, e) {\n    if (this.getState(workspace) === Constants.STATE.FLYOUT) {\n      this.resetFlyout(workspace, !!workspace.getToolbox());\n      this.setState(workspace, Constants.STATE.WORKSPACE);\n    }\n  }\n\n  /**\n   * Moves the cursor to the block level when the block the cursor is on\n   * mutates.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace the cursor belongs\n   *     to.\n   * @param {!Blockly.Events.BlockChange} e The Blockly event to process.\n   * @protected\n   */\n  handleBlockMutation(workspace, e) {\n    const mutatedBlockId = e.blockId;\n    const cursor = workspace.getCursor();\n    if (cursor) {\n      const curNode = cursor.getCurNode();\n      const block = curNode ? curNode.getSourceBlock() : null;\n      if (block && block.id === mutatedBlockId) {\n        cursor.setCurNode(Blockly.ASTNode.createBlockNode(block));\n      }\n    }\n  }\n\n  /**\n   * Moves the cursor to the workspace when a user clicks on the workspace.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace the cursor belongs\n   *     to.\n   * @param {!Blockly.Events.Click} e The Blockly event to process.\n   * @protected\n   */\n  handleWorkspaceClick(workspace, e) {\n    const workspaceState = this.getState(workspace);\n    if (workspaceState !== Constants.STATE.WORKSPACE) {\n      this.resetFlyout(workspace, !!workspace.getToolbox());\n      this.setState(workspace, Constants.STATE.WORKSPACE);\n    }\n  }\n\n  /**\n   * Moves the cursor to the toolbox when a user clicks on a toolbox category.\n   * Moves the cursor to the workspace if theh user closes the toolbox category.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace the toolbox is on.\n   * @param {!Blockly.Events.ToolboxItemSelect} e The event emitted from the\n   *     workspace.\n   * @protected\n   */\n  handleToolboxCategoryClick(workspace, e) {\n    const workspaceState = this.getState(workspace);\n    if (e.newItem && workspaceState !== Constants.STATE.TOOLBOX) {\n      // If the toolbox category was just clicked, focus on the toolbox.\n      this.focusToolbox(workspace);\n    } else if (!e.newItem) {\n      // If the toolbox was closed, focus on the workspace.\n      this.resetFlyout(workspace, !!workspace.getToolbox());\n      this.setState(workspace, Constants.STATE.WORKSPACE);\n    }\n  }\n\n  /**\n   * Moves the cursor to the workspace when its parent block is deleted by\n   * being dragged to the flyout or to the trashcan.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace the block was on.\n   * @param {!Blockly.Events.Delete} e The event emitted when a block is\n   *     deleted.\n   * @protected\n   */\n  handleBlockDeleteByDrag(workspace, e) {\n    const deletedBlockId = e.blockId;\n    const ids = e.ids;\n    const cursor = workspace.getCursor();\n\n    // Make sure the cursor is on a block.\n    if (!cursor || !cursor.getCurNode() ||\n        !cursor.getCurNode().getSourceBlock()) {\n      return;\n    }\n\n    const curNode = cursor.getCurNode();\n    const sourceBlock = curNode.getSourceBlock();\n    if (sourceBlock.id === deletedBlockId || ids.indexOf(sourceBlock.id) > -1) {\n      cursor.setCurNode(Blockly.ASTNode.createWorkspaceNode(\n          workspace, this.WS_COORDINATE_ON_DELETE));\n    }\n  }\n\n  /**\n   * Handles when a user clicks on a block in the flyout by moving the cursor\n   * to that stack of blocks and setting the state of navigation to the flyout.\n   * @param {!Blockly.WorkspaceSvg} mainWorkspace The workspace the user clicked\n   *     on.\n   * @param {!Blockly.BlockSvg} block The block the user clicked on.\n   * @protected\n   */\n  handleBlockClickInFlyout(mainWorkspace, block) {\n    if (!block) {\n      return;\n    }\n    if (block.isShadow()) {\n      block = /** @type {Blockly.BlockSvg}*/ (block.getParent());\n    }\n    this.getFlyoutCursor(mainWorkspace)\n        .setCurNode(Blockly.ASTNode.createStackNode(block));\n    this.setState(mainWorkspace, Constants.STATE.FLYOUT);\n  }\n\n  /**\n   * Moves the cursor to the appropriate location before a block is deleted.\n   * This is used when the user deletes a block using the delete or backspace\n   * key.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace the block is being\n   *     deleted on.\n   * @param {!Blockly.BlockSvg} deletedBlock The block that is being deleted.\n   * @package\n   */\n  moveCursorOnBlockDelete(workspace, deletedBlock) {\n    if (!workspace || !workspace.getCursor()) {\n      return;\n    }\n    const cursor = workspace.getCursor();\n    const curNode = cursor.getCurNode();\n    const block = curNode ? curNode.getSourceBlock() : null;\n\n    if (block === deletedBlock) {\n      // If the block has a parent move the cursor to their connection point.\n      if (block.getParent()) {\n        const topConnection =\n            block.previousConnection || block.outputConnection;\n        if (topConnection) {\n          cursor.setCurNode(Blockly.ASTNode.createConnectionNode(\n              topConnection.targetConnection));\n        }\n      } else {\n        // If the block is by itself move the cursor to the workspace.\n        cursor.setCurNode(Blockly.ASTNode.createWorkspaceNode(\n            block.workspace, block.getRelativeToSurfaceXY()));\n      }\n      // If the cursor is on a block whose parent is being deleted, move the\n      // cursor to the workspace.\n    } else if (block && deletedBlock.getChildren(false).indexOf(block) > -1) {\n      cursor.setCurNode(Blockly.ASTNode.createWorkspaceNode(\n          block.workspace, block.getRelativeToSurfaceXY()));\n    }\n  }\n\n  /**\n   * Sets the navigation state to toolbox and selects the first category in the\n   * toolbox. No-op if a toolbox does not exist on the given workspace.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace to get the toolbox\n   *     on.\n   * @package\n   */\n  focusToolbox(workspace) {\n    const toolbox = workspace.getToolbox();\n    if (!toolbox) {\n      return;\n    }\n\n    this.setState(workspace, Constants.STATE.TOOLBOX);\n    this.resetFlyout(workspace, false /* shouldHide */);\n\n    if (!this.getMarker(workspace).getCurNode()) {\n      this.markAtCursor(workspace);\n    }\n\n    if (!toolbox.getSelectedItem()) {\n      // Find the first item that is selectable.\n      const toolboxItems = toolbox.getToolboxItems();\n      for (let i = 0, toolboxItem; (toolboxItem = toolboxItems[i]); i++) {\n        if (toolboxItem.isSelectable()) {\n          toolbox.selectItemByPosition(i);\n          break;\n        }\n      }\n    }\n  }\n\n  /**\n   * Sets the navigation state to flyout and moves the cursor to the first\n   * block in the flyout.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace the flyout is on.\n   * @package\n   */\n  focusFlyout(workspace) {\n    const flyout = workspace.getFlyout();\n\n    this.setState(workspace, Constants.STATE.FLYOUT);\n\n    if (!this.getMarker(workspace).getCurNode()) {\n      this.markAtCursor(workspace);\n    }\n\n    if (flyout && flyout.getWorkspace()) {\n      const topBlocks = flyout.getWorkspace().getTopBlocks(true);\n      if (topBlocks.length > 0) {\n        const astNode = Blockly.ASTNode.createStackNode(topBlocks[0]);\n        this.getFlyoutCursor(workspace).setCurNode(astNode);\n      }\n    }\n  }\n\n  /**\n   * Sets the navigation state to workspace and moves the cursor to either the\n   * top block on a workspace or to the workspace.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace to focus on.\n   * @package\n   */\n  focusWorkspace(workspace) {\n    Blockly.hideChaff();\n    const reset = !!workspace.getToolbox();\n\n    this.resetFlyout(workspace, reset);\n    this.setState(workspace, Constants.STATE.WORKSPACE);\n    this.setCursorOnWorkspaceFocus(workspace);\n  }\n\n  /**\n   * Moves the cursor to the top connection point on on the first top block.\n   * If the workspace is empty, moves the cursor to the default location on\n   * the workspace.\n   * @param {!Blockly.WorkspaceSvg} workspace The main Blockly workspace.\n   * @protected\n   */\n  setCursorOnWorkspaceFocus(workspace) {\n    const topBlocks = workspace.getTopBlocks(true);\n    const cursor = workspace.getCursor();\n    const wsCoordinates = new Blockly.utils.Coordinate(\n        this.DEFAULT_WS_COORDINATE.x / workspace.scale,\n        this.DEFAULT_WS_COORDINATE.y / workspace.scale);\n    if (topBlocks.length > 0) {\n      cursor.setCurNode(Blockly.ASTNode.createTopNode(topBlocks[0]));\n    } else {\n      const wsNode =\n          Blockly.ASTNode.createWorkspaceNode(workspace, wsCoordinates);\n      cursor.setCurNode(wsNode);\n    }\n  }\n\n  /**\n   * Gets the cursor on the flyout's workspace.\n   * @param {!Blockly.WorkspaceSvg} workspace The main workspace the flyout is\n   *     on.\n   * @return {?Blockly.FlyoutCursor} The flyout's cursor or null if no flyout\n   *     exists.\n   * @protected\n   */\n  getFlyoutCursor(workspace) {\n    const flyout = workspace.getFlyout();\n    const cursor = flyout ? flyout.getWorkspace().getCursor() : null;\n\n    return /** @type {?Blockly.FlyoutCursor} */ (cursor);\n  }\n\n  /**\n   * Inserts a block from the flyout.\n   * Tries to find a connection on the block to connect to the marked\n   * location. If no connection has been marked, or there is not a compatible\n   * connection then the block is placed on the workspace.\n   * @param {!Blockly.WorkspaceSvg} workspace The main workspace. The workspace\n   *     the block will be placed on.\n   * @package\n   */\n  insertFromFlyout(workspace) {\n    const newBlock = this.createNewBlock(workspace);\n    if (!newBlock) {\n      return;\n    }\n    const markerNode = this.getMarker(workspace).getCurNode();\n    if (!this.tryToConnectMarkerAndCursor(\n        workspace, markerNode, Blockly.ASTNode.createBlockNode(newBlock))) {\n      this.warn(\n          'Something went wrong while inserting a block from the flyout.');\n    }\n\n    this.focusWorkspace(workspace);\n    workspace.getCursor().setCurNode(Blockly.ASTNode.createTopNode(newBlock));\n    this.removeMark(workspace);\n  }\n\n  /**\n   * Creates a new block based on the current block the flyout cursor is on.\n   * @param {!Blockly.WorkspaceSvg} workspace The main workspace. The workspace\n   *     the block will be placed on.\n   * @return {?Blockly.BlockSvg} The newly created block.\n   * @protected\n   */\n  createNewBlock(workspace) {\n    const flyout = workspace.getFlyout();\n    if (!flyout || !flyout.isVisible()) {\n      this.warn(\n          'Trying to insert from the flyout when the flyout does not ' +\n          ' exist or is not visible');\n      return null;\n    }\n\n    const curBlock = /** @type {!Blockly.BlockSvg} */ (\n      this.getFlyoutCursor(workspace).getCurNode().getLocation());\n    if (!curBlock.isEnabled()) {\n      this.warn('Can\\'t insert a disabled block.');\n      return null;\n    }\n\n    const newBlock = flyout.createBlock(curBlock);\n    // Render to get the sizing right.\n    newBlock.render();\n    // Connections are not tracked when the block is first created.  Normally\n    // there's enough time for them to become tracked in the user's mouse\n    // movements, but not here.\n    newBlock.setConnectionTracking(true);\n    return newBlock;\n  }\n\n  /**\n   * Hides the flyout cursor and optionally hides the flyout.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace.\n   * @param {boolean} shouldHide True if the flyout should be hidden.\n   * @protected\n   */\n  resetFlyout(workspace, shouldHide) {\n    if (this.getFlyoutCursor(workspace)) {\n      this.getFlyoutCursor(workspace).hide();\n      if (shouldHide) {\n        workspace.getFlyout().hide();\n      }\n    }\n  }\n\n  /**\n   * Connects the location of the marker and the location of the cursor.\n   * No-op if the marker or cursor node are null.\n   * @param {!Blockly.WorkspaceSvg} workspace The main workspace.\n   * @return {boolean} True if the cursor and marker locations were connected,\n   *     false otherwise.\n   * @package\n   */\n  connectMarkerAndCursor(workspace) {\n    const markerNode = this.getMarker(workspace).getCurNode();\n    const cursorNode = workspace.getCursor().getCurNode();\n\n    if (markerNode && cursorNode) {\n      return this.tryToConnectMarkerAndCursor(\n          workspace, markerNode, cursorNode);\n    }\n    return false;\n  }\n\n  /**\n   * Tries to connect the given marker and cursor node.\n   * @param {!Blockly.WorkspaceSvg} workspace The main workspace.\n   * @param {!Blockly.ASTNode} markerNode The node to try to connect to.\n   * @param {!Blockly.ASTNode} cursorNode The node to connect to the markerNode.\n   * @return {boolean} True if the key was handled; false if something went\n   *     wrong.\n   * @protected\n   */\n  tryToConnectMarkerAndCursor(workspace, markerNode, cursorNode) {\n    if (!this.logConnectionWarning(markerNode, cursorNode)) {\n      return false;\n    }\n\n    const markerType = markerNode.getType();\n    const cursorType = cursorNode.getType();\n\n    const cursorLoc = cursorNode.getLocation();\n    const markerLoc = markerNode.getLocation();\n    if (markerNode.isConnection() && cursorNode.isConnection()) {\n      const cursorConnection =\n      /** @type {!Blockly.RenderedConnection} */ (cursorLoc);\n      const markerConnection =\n      /** @type {!Blockly.RenderedConnection} */ (markerLoc);\n      return this.connect(cursorConnection, markerConnection);\n    } else if (\n      markerNode.isConnection() &&\n        (cursorType == Blockly.ASTNode.types.BLOCK ||\n         cursorType == Blockly.ASTNode.types.STACK)) {\n      const cursorBlock = /** @type {!Blockly.BlockSvg} */ (cursorLoc);\n      const markerConnection =\n      /** @type {!Blockly.RenderedConnection} */ (markerLoc);\n      return this.insertBlock(cursorBlock, markerConnection);\n    } else if (markerType == Blockly.ASTNode.types.WORKSPACE) {\n      const block = cursorNode ? cursorNode.getSourceBlock() : null;\n      return this.moveBlockToWorkspace(\n          /** @type {Blockly.BlockSvg} */ (block), markerNode);\n    }\n    this.warn('Unexpected state in tryToConnectMarkerAndCursor.');\n    return false;\n  }\n\n  /**\n   * Warns the user if the given cursor or marker node can not be connected.\n   * @param {!Blockly.ASTNode} markerNode The node to try to connect to.\n   * @param {!Blockly.ASTNode} cursorNode The node to connect to the markerNode.\n   * @return {boolean} True if the marker and cursor are valid types, false\n   *     otherwise.\n   * @protected\n   */\n  logConnectionWarning(markerNode, cursorNode) {\n    if (!markerNode) {\n      this.warn('Cannot insert with no marked node.');\n      return false;\n    }\n\n    if (!cursorNode) {\n      this.warn('Cannot insert with no cursor node.');\n      return false;\n    }\n    const markerType = markerNode.getType();\n    const cursorType = cursorNode.getType();\n\n    // Check the marker for invalid types.\n    if (markerType == Blockly.ASTNode.types.FIELD) {\n      this.warn('Should not have been able to mark a field.');\n      return false;\n    } else if (markerType == Blockly.ASTNode.types.BLOCK) {\n      this.warn('Should not have been able to mark a block.');\n      return false;\n    } else if (markerType == Blockly.ASTNode.types.STACK) {\n      this.warn('Should not have been able to mark a stack.');\n      return false;\n    }\n\n    // Check the cursor for invalid types.\n    if (cursorType == Blockly.ASTNode.types.FIELD) {\n      this.warn('Cannot attach a field to anything else.');\n      return false;\n    } else if (cursorType == Blockly.ASTNode.types.WORKSPACE) {\n      this.warn('Cannot attach a workspace to anything else.');\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Disconnects the block from its parent and moves it to the position of the\n   * workspace node.\n   * @param {?Blockly.BlockSvg} block The block to be moved to the workspace.\n   * @param {!Blockly.ASTNode} wsNode The workspace node holding the position\n   *     the block will be moved to.\n   * @return {boolean} True if the block can be moved to the workspace,\n   *     false otherwise.\n   * @protected\n   */\n  moveBlockToWorkspace(block, wsNode) {\n    if (!block) {\n      return false;\n    }\n    if (block.isShadow()) {\n      this.warn('Cannot move a shadow block to the workspace.');\n      return false;\n    }\n    if (block.getParent()) {\n      block.unplug(false);\n    }\n    block.moveTo(wsNode.getWsCoordinate());\n    return true;\n  }\n\n  /**\n   * Disconnects the child block from its parent block. No-op if the two given\n   * connections are unrelated.\n   * @param {!Blockly.RenderedConnection} movingConnection The connection that\n   *     is being moved.\n   * @param {!Blockly.RenderedConnection} destConnection The connection to be\n   *     moved to.\n   * @protected\n   */\n  disconnectChild(movingConnection, destConnection) {\n    const movingBlock = movingConnection.getSourceBlock();\n    const destBlock = destConnection.getSourceBlock();\n    let inferiorConnection;\n\n    if (movingBlock.getRootBlock() === destBlock.getRootBlock()) {\n      if (movingBlock.getDescendants(false).indexOf(destBlock) > -1) {\n        inferiorConnection = this.getInferiorConnection(destConnection);\n        if (inferiorConnection) {\n          inferiorConnection.disconnect();\n        }\n      } else {\n        inferiorConnection = this.getInferiorConnection(movingConnection);\n        if (inferiorConnection) {\n          inferiorConnection.disconnect();\n        }\n      }\n    }\n  }\n\n  /**\n   * Tries to connect the  given connections.\n   *\n   * If the given connections are not compatible try finding compatible\n   * connections on the source blocks of the given connections.\n   *\n   * @param {?Blockly.RenderedConnection} movingConnection The connection that\n   *     is being moved.\n   * @param {?Blockly.RenderedConnection} destConnection The connection to be\n   *     moved to.\n   * @return {boolean} True if the two connections or their target connections\n   *     were connected, false otherwise.\n   * @protected\n   */\n  connect(movingConnection, destConnection) {\n    if (!movingConnection || !destConnection) {\n      return false;\n    }\n\n    const movingInferior = this.getInferiorConnection(movingConnection);\n    const destSuperior = this.getSuperiorConnection(destConnection);\n\n    const movingSuperior = this.getSuperiorConnection(movingConnection);\n    const destInferior = this.getInferiorConnection(destConnection);\n\n    if (movingInferior && destSuperior &&\n        this.moveAndConnect(movingInferior, destSuperior)) {\n      return true;\n      // Try swapping the inferior and superior connections on the blocks.\n    } else if (\n      movingSuperior && destInferior &&\n        this.moveAndConnect(movingSuperior, destInferior)) {\n      return true;\n    } else if (this.moveAndConnect(movingConnection, destConnection)) {\n      return true;\n    } else {\n      const checker = movingConnection.getConnectionChecker();\n      const reason =\n          checker.canConnectWithReason(movingConnection, destConnection, false);\n      this.warn(\n          'Connection failed with error: ' +\n          checker.getErrorMessage(reason, movingConnection, destConnection));\n      return false;\n    }\n  }\n\n  /**\n   * Finds the inferior connection on the source block if the given connection\n   * is superior.\n   * @param {?Blockly.RenderedConnection} connection The connection trying to be\n   *     connected.\n   * @return {?Blockly.RenderedConnection} The inferior connection or null if\n   *     none exists.\n   * @protected\n   */\n  getInferiorConnection(connection) {\n    const block = /** @type{!Blockly.BlockSvg} */ (connection.getSourceBlock());\n    if (!connection.isSuperior()) {\n      return connection;\n    } else if (block.previousConnection) {\n      return block.previousConnection;\n    } else if (block.outputConnection) {\n      return block.outputConnection;\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Finds a superior connection on the source block if the given connection is\n   * inferior.\n   * @param {?Blockly.RenderedConnection} connection The connection trying to be\n   *     connected.\n   * @return {?Blockly.RenderedConnection} The superior connection or null if\n   *     none exists.\n   * @protected\n   */\n  getSuperiorConnection(connection) {\n    if (connection.isSuperior()) {\n      return connection;\n    } else if (connection.targetConnection) {\n      return connection.targetConnection;\n    }\n    return null;\n  }\n\n  /**\n   * Moves the moving connection to the target connection and connects them.\n   * @param {?Blockly.RenderedConnection} movingConnection The connection that\n   *     is being moved.\n   * @param {?Blockly.RenderedConnection} destConnection The connection to be\n   *     moved to.\n   * @return {boolean} True if the connections were connected, false otherwise.\n   * @protected\n   */\n  moveAndConnect(movingConnection, destConnection) {\n    if (!movingConnection || !destConnection) {\n      return false;\n    }\n    const movingBlock = movingConnection.getSourceBlock();\n    const checker = movingConnection.getConnectionChecker();\n\n    if (checker.canConnect(movingConnection, destConnection, false) &&\n        !destConnection.getSourceBlock().isShadow()) {\n      this.disconnectChild(movingConnection, destConnection);\n\n      // Position the root block near the connection so it does not move the\n      // other block when they are connected.\n      if (!destConnection.isSuperior()) {\n        const rootBlock = movingBlock.getRootBlock();\n        rootBlock.positionNearConnection(movingConnection, destConnection);\n      }\n      destConnection.connect(movingConnection);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Tries to connect the given block to the destination connection, making an\n   * intelligent guess about which connection to use on the moving block.\n   * @param {!Blockly.BlockSvg} block The block to move.\n   * @param {!Blockly.RenderedConnection} destConnection The connection to\n   *     connect to.\n   * @return {boolean} Whether the connection was successful.\n   * @protected\n   */\n  insertBlock(block, destConnection) {\n    switch (destConnection.type) {\n      case Blockly.PREVIOUS_STATEMENT:\n        if (this.connect(block.nextConnection, destConnection)) {\n          return true;\n        }\n        break;\n      case Blockly.NEXT_STATEMENT:\n        if (this.connect(block.previousConnection, destConnection)) {\n          return true;\n        }\n        break;\n      case Blockly.INPUT_VALUE:\n        if (this.connect(block.outputConnection, destConnection)) {\n          return true;\n        }\n        break;\n      case Blockly.OUTPUT_VALUE:\n        for (let i = 0; i < block.inputList.length; i++) {\n          const inputConnection = /** @type {Blockly.RenderedConnection} */ (\n            block.inputList[i].connection);\n          if (inputConnection && inputConnection.type === Blockly.INPUT_VALUE &&\n              this.connect(inputConnection, destConnection)) {\n            return true;\n          }\n        }\n        // If there are no input values pass the output and destination\n        // connections to connect_ to find a way to connect the two.\n        if (block.outputConnection &&\n            this.connect(block.outputConnection, destConnection)) {\n          return true;\n        }\n        break;\n    }\n    this.warn('This block can not be inserted at the marked location.');\n    return false;\n  }\n\n  /**\n   * Disconnects the connection that the cursor is pointing to, and bump blocks.\n   * This is a no-op if the connection cannot be broken or if the cursor is not\n   * pointing to a connection.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace.\n   * @package\n   */\n  disconnectBlocks(workspace) {\n    const curNode = workspace.getCursor().getCurNode();\n    if (!curNode.isConnection()) {\n      this.log(\n          'Cannot disconnect blocks when the cursor is not on a connection');\n      return;\n    }\n    const curConnection =\n    /** @type {!Blockly.RenderedConnection} */ (curNode.getLocation());\n    if (!curConnection.isConnected()) {\n      this.log('Cannot disconnect unconnected connection');\n      return;\n    }\n    const superiorConnection = curConnection.isSuperior() ?\n        curConnection :\n        curConnection.targetConnection;\n\n    const inferiorConnection = curConnection.isSuperior() ?\n        curConnection.targetConnection :\n        curConnection;\n\n    if (inferiorConnection.getSourceBlock().isShadow()) {\n      this.log('Cannot disconnect a shadow block');\n      return;\n    }\n    superiorConnection.disconnect();\n    inferiorConnection.bumpAwayFrom(superiorConnection);\n\n    const rootBlock = superiorConnection.getSourceBlock().getRootBlock();\n    rootBlock.bringToFront();\n\n    const connectionNode =\n        Blockly.ASTNode.createConnectionNode(superiorConnection);\n    workspace.getCursor().setCurNode(connectionNode);\n  }\n\n  /**\n   * Moves the marker to the cursor's current location.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace.\n   * @protected\n   */\n  markAtCursor(workspace) {\n    this.getMarker(workspace).setCurNode(workspace.getCursor().getCurNode());\n  }\n\n  /**\n   * Removes the marker from its current location and hide it.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace.\n   * @protected\n   */\n  removeMark(workspace) {\n    const marker = this.getMarker(workspace);\n    marker.setCurNode(null);\n    marker.hide();\n  }\n\n  /**\n   * Enables accessibility mode.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace to enable keyboard\n   *     accessibility mode on.\n   * @package\n   */\n  enableKeyboardAccessibility(workspace) {\n    if (this.workspaces.indexOf(workspace) > -1 &&\n        !workspace.keyboardAccessibilityMode) {\n      workspace.keyboardAccessibilityMode = true;\n      this.focusWorkspace(workspace);\n    }\n  }\n\n  /**\n   * Disables accessibility mode.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace to disable keyboard\n   *     accessibility mode on.\n   * @package\n   */\n  disableKeyboardAccessibility(workspace) {\n    if (this.workspaces.indexOf(workspace) > -1 &&\n        workspace.keyboardAccessibilityMode) {\n      workspace.keyboardAccessibilityMode = false;\n      workspace.getCursor().hide();\n      this.getMarker(workspace).hide();\n      if (this.getFlyoutCursor(workspace)) {\n        this.getFlyoutCursor(workspace).hide();\n      }\n    }\n  }\n\n  /**\n   * Navigation log handler. If loggingCallback is defined, use it.\n   * Otherwise just log to the console.log.\n   * @param {string} msg The message to log.\n   * @protected\n   */\n  log(msg) {\n    if (this.loggingCallback) {\n      this.loggingCallback(Constants.LOGGING_MSG_TYPE.LOG, msg);\n    } else {\n      console.log(msg);\n    }\n  }\n\n  /**\n   * Navigation warning handler. If loggingCallback is defined, use it.\n   * Otherwise call console.warn.\n   * @param {string} msg The warning message.\n   * @protected\n   */\n  warn(msg) {\n    if (this.loggingCallback) {\n      this.loggingCallback(Constants.LOGGING_MSG_TYPE.WARN, msg);\n    } else {\n      console.warn(msg);\n    }\n  }\n\n  /**\n   * Navigation error handler. If loggingCallback is defined, use it.\n   * Otherwise call console.error.\n   * @param {string} msg The error message.\n   * @protected\n   */\n  error(msg) {\n    if (this.loggingCallback) {\n      this.loggingCallback(Constants.LOGGING_MSG_TYPE.ERROR, msg);\n    } else {\n      console.error(msg);\n    }\n  }\n\n  /**\n   * Moves the workspace cursor in the given direction.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace the cursor is on.\n   * @param {number} xDirection -1 to move cursor left. 1 to move cursor right.\n   * @param {number} yDirection -1 to move cursor up. 1 to move cursor down.\n   * @return {boolean} True if the current node is a workspace, false otherwise.\n   * @package\n   */\n  moveWSCursor(workspace, xDirection, yDirection) {\n    const cursor = workspace.getCursor();\n    const curNode = workspace.getCursor().getCurNode();\n\n    if (curNode.getType() !== Blockly.ASTNode.types.WORKSPACE) {\n      return false;\n    }\n\n    const wsCoord = curNode.getWsCoordinate();\n    const newX = xDirection * this.WS_MOVE_DISTANCE + wsCoord.x;\n    const newY = yDirection * this.WS_MOVE_DISTANCE + wsCoord.y;\n\n    cursor.setCurNode(Blockly.ASTNode.createWorkspaceNode(\n        workspace, new Blockly.utils.Coordinate(newX, newY)));\n    return true;\n  }\n\n  /**\n   * Handles hitting the enter key on the workspace.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace.\n   * @package\n   */\n  handleEnterForWS(workspace) {\n    const cursor = workspace.getCursor();\n    const curNode = cursor.getCurNode();\n    const nodeType = curNode.getType();\n    if (nodeType == Blockly.ASTNode.types.FIELD) {\n      (/** @type {!Blockly.Field} */ (curNode.getLocation())).showEditor();\n    } else if (\n      curNode.isConnection() || nodeType == Blockly.ASTNode.types.WORKSPACE) {\n      this.markAtCursor(workspace);\n    } else if (nodeType == Blockly.ASTNode.types.BLOCK) {\n      this.warn('Cannot mark a block.');\n    } else if (nodeType == Blockly.ASTNode.types.STACK) {\n      this.warn('Cannot mark a stack.');\n    }\n  }\n\n  /**\n   * Pastes the coped block to the marked location.\n   * @return {boolean} True if the paste was sucessful, false otherwise.\n   * @package\n   */\n  paste() {\n    // TODO(google/blockly#4600):Need a way to get this value without using a\n    // private variable.\n    if (!Blockly.clipboardXml_) {\n      return false;\n    }\n    let workspace = Blockly.clipboardSource_;\n    let isHandled = false;\n\n    // Pasting always pastes to the main workspace, even if the copy\n    // started in a flyout workspace.\n    if (workspace.isFlyout) {\n      workspace = workspace.targetWorkspace;\n    }\n\n    // Handles paste for keyboard navigation.\n    if (Blockly.clipboardTypeCounts_ &&\n        workspace.isCapacityAvailable(Blockly.clipboardTypeCounts_)) {\n      Blockly.Events.setGroup(true);\n      const block = /** @type {Blockly.BlockSvg} */ (\n        Blockly.Xml.domToBlock(Blockly.clipboardXml_, workspace));\n      if (block) {\n        this.insertPastedBlock(workspace, block);\n        if (Blockly.Events.isEnabled() && !block.isShadow()) {\n          Blockly.Events.fire(new Blockly.Events.BlockCreate(block));\n        }\n        Blockly.Events.setGroup(false);\n        isHandled = true;\n      }\n    }\n    return isHandled;\n  }\n\n  /**\n   * Inserts the pasted block at the marked location if a compatible connection\n   * exists. If no connection has been marked, or there is not a compatible\n   * connection then the block is placed on the workspace.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace to paste the block\n   *     on.\n   * @param {!Blockly.BlockSvg} block The block to paste.\n   * @return {boolean} True if the block was pasted to the workspace, false\n   *     otherwise.\n   * @protected\n   */\n  insertPastedBlock(workspace, block) {\n    let isHandled = false;\n    const markedNode = workspace.getMarker(this.MARKER_NAME).getCurNode();\n    if (markedNode) {\n      isHandled = this.tryToConnectMarkerAndCursor(\n          workspace, markedNode, Blockly.ASTNode.createBlockNode(block));\n    }\n    return isHandled;\n  }\n\n  /**\n   * Removes the change listeners on all registered workspaces.\n   * @package\n   */\n  dispose() {\n    for (const workspace of this.workspaces) {\n      this.removeWorkspace(workspace);\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Overrides methods on Blockly.Gesture in order to allow users\n * to move the cursor to blocks or the workspace using shift click.\n * TODO(google/blockly#4584): We do not have a way to do this currently without\n * monkey patching Blockly.\n * @author aschmiedt@google.com (Abby Schmiedt)\n */\n\nimport * as Blockly from 'blockly/core';\n\n\nconst oldDoWorkspaceClick = Blockly.Gesture.prototype.doWorkspaceClick_;\n\n/**\n * Execute a workspace click. When in accessibility mode shift clicking will\n * move the cursor.\n * @param {!Event} e A mouse up or touch end event.\n * @this {Blockly.Gesture}\n * @override\n */\nBlockly.Gesture.prototype.doWorkspaceClick_ = function(e) {\n  oldDoWorkspaceClick.call(this, e);\n  const ws = this.creatorWorkspace_;\n  if (e.shiftKey && ws.keyboardAccessibilityMode) {\n    const screenCoord = new Blockly.utils.Coordinate(e.clientX, e.clientY);\n    const wsCoord = Blockly.utils.screenToWsCoordinates(ws, screenCoord);\n    const wsNode = Blockly.ASTNode.createWorkspaceNode(ws, wsCoord);\n    ws.getCursor().setCurNode(wsNode);\n  }\n};\n\nconst oldDoBlockClick = Blockly.Gesture.prototype.doBlockClick_;\n\n/**\n * Execute a block click. When in accessibility mode shift clicking will move\n * the cursor to the block.\n * @this {Blockly.Gesture}\n * @override\n */\nBlockly.Gesture.prototype.doBlockClick_ = function(e) {\n  oldDoBlockClick.call(this, e);\n  if (!this.targetBlock_.isInFlyout && this.mostRecentEvent_.shiftKey &&\n      this.targetBlock_.workspace.keyboardAccessibilityMode) {\n    this.creatorWorkspace_.getCursor().setCurNode(\n        Blockly.ASTNode.createTopNode(this.targetBlock_));\n  }\n};\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Registers all of the keyboard shortcuts that are necessary for\n * navigating blockly using the keyboard.\n * @author aschmiedt@google.com (Abby Schmiedt)\n */\n\nimport './gesture_monkey_patch';\n\nimport * as Blockly from 'blockly/core';\n\nimport * as Constants from './constants';\nimport {Navigation} from './navigation';\n\n/**\n * Class for registering shortcuts for keyboard navigation.\n */\nexport class NavigationController {\n  /**\n   * Constructor used for registering shortcuts.\n   * This will register any default shortcuts for keyboard navigation.\n   * This is intended to be a singleton.\n   * @param {!Navigation=} optNavigation The class that handles keyboard\n   *     navigation shortcuts. (Ex: inserting a block, focusing the flyout).\n   */\n  constructor(optNavigation) {\n    /**\n     * Handles any keyboard navigation shortcuts.\n     * @type {!Navigation}\n     * @public\n     */\n    this.navigation = optNavigation || new Navigation();\n  }\n\n  /**\n   * Registers the default keyboard shortcuts for keyboard navigation.\n   * @public\n   */\n  init() {\n    this.addShortcutHandlers();\n    this.registerDefaults();\n  }\n\n  /**\n   * Adds methods to core Blockly components that allows them to handle keyboard\n   * shortcuts when in keyboard navigation mode.\n   * @protected\n   */\n  addShortcutHandlers() {\n    if (Blockly.FieldColour) {\n      Blockly.FieldColour.prototype.onShortcut = this.fieldColourHandler;\n    }\n\n    if (Blockly.FieldDropdown) {\n      Blockly.FieldDropdown.prototype.onShortcut = this.fieldDropdownHandler;\n    }\n\n    if (Blockly.Toolbox) {\n      Blockly.Toolbox.prototype.onShortcut = this.toolboxHandler;\n    }\n  }\n\n  /**\n   * Removes methods on core Blockly components that allows them to handle\n   * keyboard shortcuts.\n   * @protected\n   */\n  removeShortcutHandlers() {\n    if (Blockly.FieldColour) {\n      Blockly.FieldColour.prototype.onShortcut = null;\n    }\n\n    if (Blockly.FieldDropdown) {\n      Blockly.FieldDropdown.prototype.onShortcut = null;\n    }\n\n    if (Blockly.Toolbox) {\n      Blockly.Toolbox.prototype.onShortcut = null;\n    }\n  }\n\n  /**\n   * Handles the given keyboard shortcut.\n   * This is only triggered when keyboard accessibility mode is enabled.\n   * @param {!Blockly.ShortcutRegistry.KeyboardShortcut} shortcut The shortcut\n   *     to be handled.\n   * @return {boolean} True if the field handled the shortcut,\n   *     false otherwise.\n   * @this {Blockly.FieldColour}\n   * @protected\n   */\n  fieldColourHandler(shortcut) {\n    if (this.picker_) {\n      switch (shortcut.name) {\n        case Constants.SHORTCUT_NAMES.PREVIOUS:\n          this.moveHighlightBy_(0, -1);\n          return true;\n        case Constants.SHORTCUT_NAMES.NEXT:\n          this.moveHighlightBy_(0, 1);\n          return true;\n        case Constants.SHORTCUT_NAMES.OUT:\n          this.moveHighlightBy_(-1, 0);\n          return true;\n        case Constants.SHORTCUT_NAMES.IN:\n          this.moveHighlightBy_(1, 0);\n          return true;\n        default:\n          return false;\n      }\n    }\n    return Blockly.FieldColour.superClass_.onShortcut.call(this, shortcut);\n  }\n\n  /**\n   * Handles the given keyboard shortcut.\n   * This is only triggered when keyboard accessibility mode is enabled.\n   * @param {!Blockly.ShortcutRegistry.KeyboardShortcut} shortcut The shortcut\n   *     to be handled.\n   * @return {boolean} True if the field handled the shortcut,\n   *     false otherwise.\n   * @this {Blockly.FieldDropdown}\n   * @protected\n   */\n  fieldDropdownHandler(shortcut) {\n    if (this.menu_) {\n      switch (shortcut.name) {\n        case Constants.SHORTCUT_NAMES.PREVIOUS:\n          this.menu_.highlightPrevious();\n          return true;\n        case Constants.SHORTCUT_NAMES.NEXT:\n          this.menu_.highlightNext();\n          return true;\n        default:\n          return false;\n      }\n    }\n    return Blockly.FieldDropdown.superClass_.onShortcut.call(this, shortcut);\n  }\n\n  /**\n   * Handles the given keyboard shortcut.\n   * This is only triggered when keyboard accessibility mode is enabled.\n   * @param {!Blockly.ShortcutRegistry.KeyboardShortcut} shortcut The shortcut\n   *     to be handled.\n   * @return {boolean} True if the toolbox handled the shortcut,\n   *     false otherwise.\n   * @this {Blockly.Toolbox}\n   * @protected\n   */\n  toolboxHandler(shortcut) {\n    if (!this.selectedItem_) {\n      return false;\n    }\n    switch (shortcut.name) {\n      case Constants.SHORTCUT_NAMES.PREVIOUS:\n        return this.selectPrevious_();\n      case Constants.SHORTCUT_NAMES.OUT:\n        return this.selectParent_();\n      case Constants.SHORTCUT_NAMES.NEXT:\n        return this.selectNext_();\n      case Constants.SHORTCUT_NAMES.IN:\n        return this.selectChild_();\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * Adds all necessary event listeners and markers to a workspace for keyboard\n   * navigation to work. This must be called for keyboard navigation to work\n   * on a workspace.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace to add keyboard\n   *     navigation to.\n   * @public\n   */\n  addWorkspace(workspace) {\n    this.navigation.addWorkspace(workspace);\n  }\n\n  /**\n   * Removes all necessary event listeners and markers to a workspace for\n   * keyboard navigation to work.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace to remove keyboard\n   *     navigation from.\n   * @public\n   */\n  removeWorkspace(workspace) {\n    this.navigation.removeWorkspace(workspace);\n  }\n\n  /**\n   * Turns on keyboard navigation.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace to turn on keyboard\n   *     navigation for.\n   * @public\n   */\n  enable(workspace) {\n    this.navigation.enableKeyboardAccessibility(workspace);\n  }\n\n  /**\n   * Turns off keyboard navigation.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace to turn off keyboard\n   *     navigation on.\n   * @public\n   */\n  disable(workspace) {\n    this.navigation.disableKeyboardAccessibility(workspace);\n  }\n\n  /**\n   * Gives the cursor to the field to handle if the cursor is on a field.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace to check.\n   * @param {!Blockly.ShortcutRegistry.KeyboardShortcut} shortcut The shortcut\n   *     to give to the field.\n   * @return {boolean} True if the shortcut was handled by the field, false\n   *     otherwise.\n   * @protected\n   */\n  fieldShortcutHandler(workspace, shortcut) {\n    const cursor = workspace.getCursor();\n    if (!cursor || !cursor.getCurNode()) {\n      return;\n    }\n    const curNode = cursor.getCurNode();\n    if (curNode.getType() === Blockly.ASTNode.types.FIELD) {\n      return (/** @type {!Blockly.Field} */ (curNode.getLocation()))\n          .onShortcut(shortcut);\n    }\n    return false;\n  }\n\n  /**\n   * Keyboard shortcut to go to the previous location when in keyboard\n   * navigation mode.\n   * @protected\n   */\n  registerPrevious() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const previousShortcut = {\n      name: Constants.SHORTCUT_NAMES.PREVIOUS,\n      preconditionFn: (workspace) => {\n        return workspace.keyboardAccessibilityMode;\n      },\n      callback: (workspace, e, shortcut) => {\n        const flyout = workspace.getFlyout();\n        const toolbox = workspace.getToolbox();\n        let isHandled = false;\n        switch (this.navigation.getState(workspace)) {\n          case Constants.STATE.WORKSPACE:\n            isHandled = this.fieldShortcutHandler(workspace, shortcut);\n            if (!isHandled) {\n              workspace.getCursor().prev();\n              isHandled = true;\n            }\n            return isHandled;\n          case Constants.STATE.FLYOUT:\n            isHandled = this.fieldShortcutHandler(workspace, shortcut);\n            if (!isHandled) {\n              flyout.getWorkspace().getCursor().prev();\n              isHandled = true;\n            }\n            return isHandled;\n          case Constants.STATE.TOOLBOX:\n            return toolbox && typeof toolbox.onShortcut == 'function' ?\n                toolbox.onShortcut(shortcut) :\n                false;\n          default:\n            return false;\n        }\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(previousShortcut);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n        Blockly.utils.KeyCodes.W, previousShortcut.name);\n  }\n\n  /**\n   * Keyboard shortcut to turn keyboard navigation on or off.\n   * @protected\n   */\n  registerToggleKeyboardNav() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const toggleKeyboardNavShortcut = {\n      name: Constants.SHORTCUT_NAMES.TOGGLE_KEYBOARD_NAV,\n      callback: (workspace) => {\n        if (workspace.keyboardAccessibilityMode) {\n          this.navigation.disableKeyboardAccessibility(workspace);\n        } else {\n          this.navigation.enableKeyboardAccessibility(workspace);\n        }\n        return true;\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(toggleKeyboardNavShortcut);\n    const ctrlShiftK = Blockly.ShortcutRegistry.registry.createSerializedKey(\n        Blockly.utils.KeyCodes.K,\n        [Blockly.utils.KeyCodes.CTRL, Blockly.utils.KeyCodes.SHIFT]);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n        ctrlShiftK, toggleKeyboardNavShortcut.name);\n  }\n\n  /**\n   * Keyboard shortcut to go to the out location when in keyboard navigation\n   * mode.\n   * @protected\n   */\n  registerOut() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const outShortcut = {\n      name: Constants.SHORTCUT_NAMES.OUT,\n      preconditionFn: (workspace) => {\n        return workspace.keyboardAccessibilityMode;\n      },\n      callback: (workspace, e, shortcut) => {\n        const toolbox = workspace.getToolbox();\n        let isHandled = false;\n        switch (this.navigation.getState(workspace)) {\n          case Constants.STATE.WORKSPACE:\n            isHandled = this.fieldShortcutHandler(workspace, shortcut);\n            if (!isHandled) {\n              workspace.getCursor().out();\n              isHandled = true;\n            }\n            return isHandled;\n          case Constants.STATE.FLYOUT:\n            this.navigation.focusToolbox(workspace);\n            return true;\n          case Constants.STATE.TOOLBOX:\n            return toolbox && typeof toolbox.onShortcut == 'function' ?\n                toolbox.onShortcut(shortcut) :\n                false;\n          default:\n            return false;\n        }\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(outShortcut);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n        Blockly.utils.KeyCodes.A, outShortcut.name);\n  }\n\n  /**\n   * Keyboard shortcut to go to the next location when in keyboard navigation\n   * mode.\n   * @protected\n   */\n  registerNext() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const nextShortcut = {\n      name: Constants.SHORTCUT_NAMES.NEXT,\n      preconditionFn: (workspace) => {\n        return workspace.keyboardAccessibilityMode;\n      },\n      callback: (workspace, e, shortcut) => {\n        const toolbox = workspace.getToolbox();\n        const flyout = workspace.getFlyout();\n        let isHandled = false;\n        switch (this.navigation.getState(workspace)) {\n          case Constants.STATE.WORKSPACE:\n            isHandled = this.fieldShortcutHandler(workspace, shortcut);\n            if (!isHandled) {\n              workspace.getCursor().next();\n              isHandled = true;\n            }\n            return isHandled;\n          case Constants.STATE.FLYOUT:\n            isHandled = this.fieldShortcutHandler(workspace, shortcut);\n            if (!isHandled) {\n              flyout.getWorkspace().getCursor().next();\n              isHandled = true;\n            }\n            return isHandled;\n          case Constants.STATE.TOOLBOX:\n            return toolbox && typeof toolbox.onShortcut == 'function' ?\n                toolbox.onShortcut(shortcut) :\n                false;\n          default:\n            return false;\n        }\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(nextShortcut);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n        Blockly.utils.KeyCodes.S, nextShortcut.name);\n  }\n\n  /**\n   * Keyboard shortcut to go to the in location when in keyboard navigation\n   * mode.\n   * @protected\n   */\n  registerIn() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const inShortcut = {\n      name: Constants.SHORTCUT_NAMES.IN,\n      preconditionFn: (workspace) => {\n        return workspace.keyboardAccessibilityMode;\n      },\n      callback: (workspace, e, shortcut) => {\n        const toolbox = workspace.getToolbox();\n        let isHandled = false;\n        switch (this.navigation.getState(workspace)) {\n          case Constants.STATE.WORKSPACE:\n            isHandled = this.fieldShortcutHandler(workspace, shortcut);\n            if (!isHandled) {\n              workspace.getCursor().in();\n              isHandled = true;\n            }\n            return isHandled;\n          case Constants.STATE.TOOLBOX:\n            isHandled = toolbox && typeof toolbox.onShortcut == 'function' ?\n                toolbox.onShortcut(shortcut) :\n                false;\n            if (!isHandled) {\n              this.navigation.focusFlyout(workspace);\n            }\n            return true;\n          default:\n            return false;\n        }\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(inShortcut);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n        Blockly.utils.KeyCodes.D, inShortcut.name);\n  }\n\n  /**\n   * Keyboard shortcut to connect a block to a marked location when in keyboard\n   * navigation mode.\n   * @protected\n   */\n  registerInsert() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const insertShortcut = {\n      name: Constants.SHORTCUT_NAMES.INSERT,\n      preconditionFn: (workspace) => {\n        return workspace.keyboardAccessibilityMode &&\n            !workspace.options.readOnly;\n      },\n      callback: (workspace) => {\n        switch (this.navigation.getState(workspace)) {\n          case Constants.STATE.WORKSPACE:\n            return this.navigation.connectMarkerAndCursor(workspace);\n          default:\n            return false;\n        }\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(insertShortcut);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n        Blockly.utils.KeyCodes.I, insertShortcut.name);\n  }\n\n  /**\n   * Keyboard shortcut to mark a location when in keyboard navigation mode.\n   * @protected\n   */\n  registerMark() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const markShortcut = {\n      name: Constants.SHORTCUT_NAMES.MARK,\n      preconditionFn: (workspace) => {\n        return workspace.keyboardAccessibilityMode &&\n            !workspace.options.readOnly;\n      },\n      callback: (workspace) => {\n        switch (this.navigation.getState(workspace)) {\n          case Constants.STATE.WORKSPACE:\n            this.navigation.handleEnterForWS(workspace);\n            return true;\n          case Constants.STATE.FLYOUT:\n            this.navigation.insertFromFlyout(workspace);\n            return true;\n          default:\n            return false;\n        }\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(markShortcut);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n        Blockly.utils.KeyCodes.ENTER, markShortcut.name);\n  }\n\n  /**\n   * Keyboard shortcut to disconnect two blocks when in keyboard navigation\n   * mode.\n   * @protected\n   */\n  registerDisconnect() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const disconnectShortcut = {\n      name: Constants.SHORTCUT_NAMES.DISCONNECT,\n      preconditionFn: (workspace) => {\n        return workspace.keyboardAccessibilityMode &&\n            !workspace.options.readOnly;\n      },\n      callback: (workspace) => {\n        switch (this.navigation.getState(workspace)) {\n          case Constants.STATE.WORKSPACE:\n            this.navigation.disconnectBlocks(workspace);\n            return true;\n          default:\n            return false;\n        }\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(disconnectShortcut);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n        Blockly.utils.KeyCodes.X, disconnectShortcut.name);\n  }\n\n  /**\n   * Keyboard shortcut to focus on the toolbox when in keyboard navigation\n   * mode.\n   * @protected\n   */\n  registerToolboxFocus() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const focusToolboxShortcut = {\n      name: Constants.SHORTCUT_NAMES.TOOLBOX,\n      preconditionFn: (workspace) => {\n        return workspace.keyboardAccessibilityMode &&\n            !workspace.options.readOnly;\n      },\n      callback: (workspace) => {\n        switch (this.navigation.getState(workspace)) {\n          case Constants.STATE.WORKSPACE:\n            if (!workspace.getToolbox()) {\n              this.navigation.focusFlyout(workspace);\n            } else {\n              this.navigation.focusToolbox(workspace);\n            }\n            return true;\n          default:\n            return false;\n        }\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(focusToolboxShortcut);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n        Blockly.utils.KeyCodes.T, focusToolboxShortcut.name);\n  }\n\n  /**\n   * Keyboard shortcut to exit the current location and focus on the workspace\n   * when in keyboard navigation mode.\n   * @protected\n   */\n  registerExit() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const exitShortcut = {\n      name: Constants.SHORTCUT_NAMES.EXIT,\n      preconditionFn: (workspace) => {\n        return workspace.keyboardAccessibilityMode;\n      },\n      callback: (workspace) => {\n        switch (this.navigation.getState(workspace)) {\n          case Constants.STATE.FLYOUT:\n            this.navigation.focusWorkspace(workspace);\n            return true;\n          case Constants.STATE.TOOLBOX:\n            this.navigation.focusWorkspace(workspace);\n            return true;\n          default:\n            return false;\n        }\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(exitShortcut, true);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n        Blockly.utils.KeyCodes.ESC, exitShortcut.name, true);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n        Blockly.utils.KeyCodes.E, exitShortcut.name, true);\n  }\n\n  /**\n   * Keyboard shortcut to move the cursor on the workspace to the left when in\n   * keyboard navigation mode.\n   * @protected\n   */\n  registerWorkspaceMoveLeft() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const wsMoveLeftShortcut = {\n      name: Constants.SHORTCUT_NAMES.MOVE_WS_CURSOR_LEFT,\n      preconditionFn: (workspace) => {\n        return workspace.keyboardAccessibilityMode &&\n            !workspace.options.readOnly;\n      },\n      callback: (workspace) => {\n        return this.navigation.moveWSCursor(workspace, -1, 0);\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(wsMoveLeftShortcut);\n    const shiftA = Blockly.ShortcutRegistry.registry.createSerializedKey(\n        Blockly.utils.KeyCodes.A, [Blockly.utils.KeyCodes.SHIFT]);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n        shiftA, wsMoveLeftShortcut.name);\n  }\n\n  /**\n   * Keyboard shortcut to move the cursor on the workspace to the right when in\n   * keyboard navigation mode.\n   * @protected\n   */\n  registerWorkspaceMoveRight() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const wsMoveRightShortcut = {\n      name: Constants.SHORTCUT_NAMES.MOVE_WS_CURSOR_RIGHT,\n      preconditionFn: (workspace) => {\n        return workspace.keyboardAccessibilityMode &&\n            !workspace.options.readOnly;\n      },\n      callback: (workspace) => {\n        return this.navigation.moveWSCursor(workspace, 1, 0);\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(wsMoveRightShortcut);\n    const shiftD = Blockly.ShortcutRegistry.registry.createSerializedKey(\n        Blockly.utils.KeyCodes.D, [Blockly.utils.KeyCodes.SHIFT]);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n        shiftD, wsMoveRightShortcut.name);\n  }\n\n  /**\n   * Keyboard shortcut to move the cursor on the workspace up when in keyboard\n   * navigation mode.\n   * @protected\n   */\n  registerWorkspaceMoveUp() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const wsMoveUpShortcut = {\n      name: Constants.SHORTCUT_NAMES.MOVE_WS_CURSOR_UP,\n      preconditionFn: (workspace) => {\n        return workspace.keyboardAccessibilityMode &&\n            !workspace.options.readOnly;\n      },\n      callback: (workspace) => {\n        return this.navigation.moveWSCursor(workspace, 0, -1);\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(wsMoveUpShortcut);\n    const shiftW = Blockly.ShortcutRegistry.registry.createSerializedKey(\n        Blockly.utils.KeyCodes.W, [Blockly.utils.KeyCodes.SHIFT]);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n        shiftW, wsMoveUpShortcut.name);\n  }\n\n  /**\n   * Keyboard shortcut to move the cursor on the workspace down when in\n   * keyboard navigation mode.\n   * @protected\n   */\n  registerWorkspaceMoveDown() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const wsMoveDownShortcut = {\n      name: Constants.SHORTCUT_NAMES.MOVE_WS_CURSOR_DOWN,\n      preconditionFn: (workspace) => {\n        return workspace.keyboardAccessibilityMode &&\n            !workspace.options.readOnly;\n      },\n      callback: (workspace) => {\n        return this.navigation.moveWSCursor(workspace, 0, 1);\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(wsMoveDownShortcut);\n    const shiftW = Blockly.ShortcutRegistry.registry.createSerializedKey(\n        Blockly.utils.KeyCodes.S, [Blockly.utils.KeyCodes.SHIFT]);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n        shiftW, wsMoveDownShortcut.name);\n  }\n\n  /**\n   * Keyboard shortcut to copy the block the cursor is currently on.\n   * @protected\n   */\n  registerCopy() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const copyShortcut = {\n      name: Constants.SHORTCUT_NAMES.COPY,\n      preconditionFn: (workspace) => {\n        if (workspace.keyboardAccessibilityMode &&\n            !workspace.options.readOnly) {\n          const curNode = workspace.getCursor().getCurNode();\n          if (curNode && curNode.getSourceBlock()) {\n            const sourceBlock = curNode.getSourceBlock();\n            return !Blockly.Gesture.inProgress() && sourceBlock &&\n                sourceBlock.isDeletable() && sourceBlock.isMovable();\n          }\n        }\n        return false;\n      },\n      callback: (workspace) => {\n        const sourceBlock = workspace.getCursor().getCurNode().getSourceBlock();\n        Blockly.hideChaff();\n        Blockly.copy(sourceBlock);\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(copyShortcut);\n\n    const ctrlC = Blockly.ShortcutRegistry.registry.createSerializedKey(\n        Blockly.utils.KeyCodes.C, [Blockly.utils.KeyCodes.CTRL]);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n        ctrlC, copyShortcut.name, true);\n\n    const altC = Blockly.ShortcutRegistry.registry.createSerializedKey(\n        Blockly.utils.KeyCodes.C, [Blockly.utils.KeyCodes.ALT]);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n        altC, copyShortcut.name, true);\n\n    const metaC = Blockly.ShortcutRegistry.registry.createSerializedKey(\n        Blockly.utils.KeyCodes.C, [Blockly.utils.KeyCodes.META]);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n        metaC, copyShortcut.name, true);\n  }\n\n  /**\n   * Register shortcut to paste the copied block to the marked location.\n   * @protected\n   */\n  registerPaste() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const pasteShortcut = {\n      name: Constants.SHORTCUT_NAMES.PASTE,\n      preconditionFn: (workspace) => {\n        return workspace.keyboardAccessibilityMode &&\n            !workspace.options.readOnly && !Blockly.Gesture.inProgress();\n      },\n      callback: () => {\n        return this.navigation.paste();\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(pasteShortcut);\n\n    const ctrlV = Blockly.ShortcutRegistry.registry.createSerializedKey(\n        Blockly.utils.KeyCodes.V, [Blockly.utils.KeyCodes.CTRL]);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n        ctrlV, pasteShortcut.name, true);\n\n    const altV = Blockly.ShortcutRegistry.registry.createSerializedKey(\n        Blockly.utils.KeyCodes.V, [Blockly.utils.KeyCodes.ALT]);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n        altV, pasteShortcut.name, true);\n\n    const metaV = Blockly.ShortcutRegistry.registry.createSerializedKey(\n        Blockly.utils.KeyCodes.V, [Blockly.utils.KeyCodes.META]);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n        metaV, pasteShortcut.name, true);\n  }\n\n  /**\n   * Keyboard shortcut to copy and delete the block the cursor is on using\n   * ctrl+x, cmd+x, or alt+x.\n   * @protected\n   */\n  registerCut() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const cutShortcut = {\n      name: Constants.SHORTCUT_NAMES.CUT,\n      preconditionFn: (workspace) => {\n        if (workspace.keyboardAccessibilityMode &&\n            !workspace.options.readOnly) {\n          const curNode = workspace.getCursor().getCurNode();\n          if (curNode && curNode.getSourceBlock()) {\n            const sourceBlock = curNode.getSourceBlock();\n            return !Blockly.Gesture.inProgress() && sourceBlock &&\n                sourceBlock.isDeletable() && sourceBlock.isMovable() &&\n                !sourceBlock.workspace.isFlyout;\n          }\n        }\n        return false;\n      },\n      callback: (workspace) => {\n        const sourceBlock = workspace.getCursor().getCurNode().getSourceBlock();\n        Blockly.copy(sourceBlock);\n        this.navigation.moveCursorOnBlockDelete(workspace, sourceBlock);\n        Blockly.deleteBlock(sourceBlock);\n        return true;\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(cutShortcut);\n\n    const ctrlX = Blockly.ShortcutRegistry.registry.createSerializedKey(\n        Blockly.utils.KeyCodes.X, [Blockly.utils.KeyCodes.CTRL]);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n        ctrlX, cutShortcut.name, true);\n\n    const altX = Blockly.ShortcutRegistry.registry.createSerializedKey(\n        Blockly.utils.KeyCodes.X, [Blockly.utils.KeyCodes.ALT]);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n        altX, cutShortcut.name, true);\n\n    const metaX = Blockly.ShortcutRegistry.registry.createSerializedKey(\n        Blockly.utils.KeyCodes.X, [Blockly.utils.KeyCodes.META]);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n        metaX, cutShortcut.name, true);\n  }\n\n  /**\n   * Registers shortcut to delete the block the cursor is on using delete or\n   * backspace.\n   * @protected\n   */\n  registerDelete() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const deleteShortcut = {\n      name: Constants.SHORTCUT_NAMES.DELETE,\n      preconditionFn: function(workspace) {\n        if (workspace.keyboardAccessibilityMode &&\n            !workspace.options.readOnly) {\n          const curNode = workspace.getCursor().getCurNode();\n          if (curNode && curNode.getSourceBlock()) {\n            const sourceBlock = curNode.getSourceBlock();\n            return sourceBlock && sourceBlock.isDeletable();\n          }\n        }\n        return false;\n      },\n      callback: (workspace, e) => {\n        const sourceBlock = workspace.getCursor().getCurNode().getSourceBlock();\n        // Delete or backspace.\n        // Stop the browser from going back to the previous page.\n        // Do this first to prevent an error in the delete code from resulting\n        // in data loss.\n        e.preventDefault();\n        // Don't delete while dragging.  Jeez.\n        if (Blockly.Gesture.inProgress()) {\n          return false;\n        }\n        this.navigation.moveCursorOnBlockDelete(workspace, sourceBlock);\n        Blockly.deleteBlock(sourceBlock);\n        return true;\n      },\n    };\n    Blockly.ShortcutRegistry.registry.register(deleteShortcut);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n        Blockly.utils.KeyCodes.DELETE, deleteShortcut.name, true);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n        Blockly.utils.KeyCodes.BACKSPACE, deleteShortcut.name, true);\n  }\n\n  /**\n   * Registers all default keyboard shortcut items for keyboard navigation. This\n   * should be called once per instance of KeyboardShortcutRegistry.\n   * @protected\n   */\n  registerDefaults() {\n    this.registerPrevious();\n    this.registerNext();\n    this.registerIn();\n    this.registerOut();\n\n    this.registerDisconnect();\n    this.registerExit();\n    this.registerInsert();\n    this.registerMark();\n    this.registerToolboxFocus();\n    this.registerToggleKeyboardNav();\n\n    this.registerWorkspaceMoveDown();\n    this.registerWorkspaceMoveLeft();\n    this.registerWorkspaceMoveUp();\n    this.registerWorkspaceMoveRight();\n\n    this.registerCopy();\n    this.registerPaste();\n    this.registerCut();\n    this.registerDelete();\n  }\n\n  /**\n   * Removes all the keyboard navigation shortcuts.\n   * @public\n   */\n  dispose() {\n    const shortcutNames = Object.values(Constants.SHORTCUT_NAMES);\n    for (const name of shortcutNames) {\n      Blockly.ShortcutRegistry.registry.unregister(name);\n    }\n    this.removeShortcutHandlers();\n    this.navigation.dispose();\n  }\n}\n"],"sourceRoot":""}