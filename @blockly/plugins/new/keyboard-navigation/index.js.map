{"version":3,"file":"index.js","mappings":"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","sources":["webpack://@blockly/keyboard-navigation/webpack/universalModuleDefinition","webpack://@blockly/keyboard-navigation/external umd {\"root\":\"Blockly\",\"commonjs\":\"blockly/core\",\"commonjs2\":\"blockly/core\",\"amd\":\"blockly/core\"}","webpack://@blockly/keyboard-navigation/webpack/bootstrap","webpack://@blockly/keyboard-navigation/webpack/runtime/define property getters","webpack://@blockly/keyboard-navigation/webpack/runtime/hasOwnProperty shorthand","webpack://@blockly/keyboard-navigation/webpack/runtime/make namespace object","webpack://@blockly/keyboard-navigation/./src/constants.js","webpack://@blockly/keyboard-navigation/./src/flyout_cursor.js","webpack://@blockly/keyboard-navigation/./src/line_cursor.js","webpack://@blockly/keyboard-navigation/./src/navigation.js","webpack://@blockly/keyboard-navigation/./src/gesture_monkey_patch.js","webpack://@blockly/keyboard-navigation/./src/navigation_controller.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"blockly/core\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"blockly/core\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"blockly/core\")) : factory(root[\"Blockly\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function(__WEBPACK_EXTERNAL_MODULE__573__) {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__573__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Constants for keyboard navigation.\n * @author aschmiedt@google.com (Abby Schmiedt)\n */\n\n/**\n * Keyboard navigation states.\n * The different parts of Blockly that the user navigates between.\n * @enum {string}\n * @const\n * @public\n */\nexport const STATE = {\n  WORKSPACE: 'workspace',\n  FLYOUT: 'flyout',\n  TOOLBOX: 'toolbox',\n};\n\n/**\n * Default keyboard navigation shortcut names.\n * @enum {string}\n * @const\n * @public\n */\nexport const SHORTCUT_NAMES = {\n  PREVIOUS: 'previous',\n  NEXT: 'next',\n  IN: 'in',\n  OUT: 'out',\n  INSERT: 'insert',\n  MARK: 'mark',\n  DISCONNECT: 'disconnect',\n  TOOLBOX: 'toolbox',\n  EXIT: 'exit',\n  TOGGLE_KEYBOARD_NAV: 'toggle_keyboard_nav',\n  COPY: 'keyboard_nav_copy',\n  CUT: 'keyboard_nav_cut',\n  PASTE: 'keyboard_nav_paste',\n  DELETE: 'keyboard_nav_delete',\n  MOVE_WS_CURSOR_UP: 'workspace_up',\n  MOVE_WS_CURSOR_DOWN: 'workspace_down',\n  MOVE_WS_CURSOR_LEFT: 'workspace_left',\n  MOVE_WS_CURSOR_RIGHT: 'workspace_right',\n};\n\n/**\n * Types of possible messages passed into the loggingCallback in the Navigation\n * class.\n * @enum {string}\n * @const\n * @public\n */\nexport const LOGGING_MSG_TYPE = {\n  ERROR: 'error',\n  WARN: 'warn',\n  LOG: 'log',\n};\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The class representing a cursor used to navigate the flyout.\n * @author aschmiedt@google.com (Abby Schmiedt)\n */\n\nimport * as Blockly from 'blockly/core';\n\n/**\n * Class for a flyout cursor.\n * This controls how a user navigates blocks in the flyout.\n * This cursor only allows a user to go to the previous or next stack.\n * @constructor\n * @extends {Blockly.Cursor}\n */\nexport class FlyoutCursor extends Blockly.Cursor {\n  /**\n   * The constructor for the FlyoutCursor.\n   */\n  constructor() {\n    super();\n  }\n\n  /**\n   * Moves the cursor to the next stack of blocks in the flyout.\n   * @return {Blockly.ASTNode} The next element, or null if the current node is\n   *     not set or there is no next value.\n   * @override\n   */\n  next() {\n    const curNode = this.getCurNode();\n    if (!curNode) {\n      return null;\n    }\n    const newNode = curNode.next();\n\n    if (newNode) {\n      this.setCurNode(newNode);\n    }\n    return newNode;\n  }\n\n  /**\n   * This is a no-op since a flyout cursor can not go in.\n   * @return {null} Always null.\n   * @override\n   */\n  in() {\n    return null;\n  }\n\n  /**\n   * Moves the cursor to the previous stack of blocks in the flyout.\n   * @return {Blockly.ASTNode} The previous element, or null if the current node\n   *     is not set or there is no previous value.\n   * @override\n   */\n  prev() {\n    const curNode = this.getCurNode();\n    if (!curNode) {\n      return null;\n    }\n    const newNode = curNode.prev();\n\n    if (newNode) {\n      this.setCurNode(newNode);\n    }\n    return newNode;\n  }\n\n  /**\n   * This is a  no-op since a flyout cursor can not go out.\n   * @return {null} Always null.\n   * @override\n   */\n  out() {\n    return null;\n  }\n}\n\nexport const registrationType = Blockly.registry.Type.CURSOR;\nexport const registrationName = 'FlyoutCursor';\n\nBlockly.registry.register(registrationType, registrationName, FlyoutCursor);\n\nexport const pluginInfo = {\n  [registrationType]: registrationName,\n};\n","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The class representing a line cursor.\n * A line cursor tries to traverse the blocks and connections on a block as if\n * they were lines of code in a text editor. Previous and next traverse previous\n * connections, next connections and blocks, while in and out traverse input\n * connections and fields.\n * @author aschmiedt@google.com (Abby Schmiedt)\n */\n\nimport * as Blockly from 'blockly/core';\n\n/**\n * Class for a line cursor.\n * @constructor\n * @extends {Blockly.BasicCursor}\n */\nexport class LineCursor extends Blockly.BasicCursor {\n  /**\n   * Constructor for a line cursor.\n   */\n  constructor() {\n    super();\n  }\n\n  /**\n   * Moves the cursor to the next previous connection, next connection or block\n   * in the pre order traversal. Finds the next node in the pre order traversal.\n   * @return {Blockly.ASTNode} The next node, or null if the current node is\n   *     not set or there is no next value.\n   * @override\n   */\n  next() {\n    const curNode = this.getCurNode();\n    if (!curNode) {\n      return null;\n    }\n    let newNode = this.getNextNode_(curNode, this.validLineNode);\n\n    // Skip the input or next value if there is a connected block.\n    if (newNode &&\n        (newNode.getType() == Blockly.ASTNode.types.INPUT ||\n         newNode.getType() == Blockly.ASTNode.types.NEXT) &&\n        newNode.getLocation().targetBlock()) {\n      newNode = this.getNextNode_(newNode, this.validLineNode);\n    }\n    if (newNode) {\n      this.setCurNode(newNode);\n    }\n    return newNode;\n  }\n\n  /**\n   * Moves the cursor to the next input connection or field\n   * in the pre order traversal.\n   * @return {Blockly.ASTNode} The next node, or null if the current node is\n   *     not set or there is no next value.\n   * @override\n   */\n  in() {\n    const curNode = this.getCurNode();\n    if (!curNode) {\n      return null;\n    }\n    const newNode = this.getNextNode_(curNode, this.validInLineNode);\n\n    if (newNode) {\n      this.setCurNode(newNode);\n    }\n    return newNode;\n  }\n  /**\n   * Moves the cursor to the previous next connection or previous connection in\n   * the pre order traversal.\n   * @return {Blockly.ASTNode} The previous node, or null if the current node\n   *     is not set or there is no previous value.\n   * @override\n   */\n  prev() {\n    const curNode = this.getCurNode();\n    if (!curNode) {\n      return null;\n    }\n    let newNode = this.getPreviousNode_(curNode, this.validLineNode);\n\n    if (newNode &&\n        (newNode.getType() == Blockly.ASTNode.types.INPUT ||\n         newNode.getType() == Blockly.ASTNode.types.NEXT) &&\n        newNode.getLocation().targetBlock()) {\n      newNode = this.getPreviousNode_(newNode, this.validLineNode);\n    }\n\n    if (newNode) {\n      this.setCurNode(newNode);\n    }\n    return newNode;\n  }\n  /**\n   * Moves the cursor to the previous input connection or field in the pre order\n   * traversal.\n   * @return {Blockly.ASTNode} The previous node, or null if the current node is\n   *     not set or there is no previous value.\n   * @override\n   */\n  out() {\n    const curNode = this.getCurNode();\n    if (!curNode) {\n      return null;\n    }\n    const newNode = this.getPreviousNode_(curNode, this.validInLineNode);\n\n    if (newNode) {\n      this.setCurNode(newNode);\n    }\n    return newNode;\n  }\n\n  /**\n   * Decides if the previous and next methods should traverse the given node.\n   * The previous and next method only traverse previous connections, next\n   * connections and blocks.\n   * @param {Blockly.ASTNode} node The AST node to check.\n   * @return {boolean} True if the node should be visited, false otherwise.\n   * @protected\n   */\n  validLineNode(node) {\n    if (!node) {\n      return false;\n    }\n    let isValid = false;\n    const location = node.getLocation();\n    const type = node && node.getType();\n    if (type == Blockly.ASTNode.types.BLOCK) {\n      if (location.outputConnection === null) {\n        isValid = true;\n      }\n    } else if (\n      type == Blockly.ASTNode.types.INPUT &&\n        location.type == Blockly.NEXT_STATEMENT) {\n      isValid = true;\n    } else if (type == Blockly.ASTNode.types.NEXT) {\n      isValid = true;\n    }\n    return isValid;\n  }\n\n  /**\n   * Decides if the in and out methods should traverse the given node.\n   * The in and out method only traverse fields and input connections.\n   * @param {Blockly.ASTNode} node The AST node to check whether it is valid.\n   * @return {boolean} True if the node should be visited, false otherwise.\n   * @protected\n   */\n  validInLineNode(node) {\n    if (!node) {\n      return false;\n    }\n    let isValid = false;\n    const location = node.getLocation();\n    const type = node && node.getType();\n    if (type == Blockly.ASTNode.types.FIELD) {\n      isValid = true;\n    } else if (\n      type == Blockly.ASTNode.types.INPUT &&\n        location.type == Blockly.INPUT_VALUE) {\n      isValid = true;\n    }\n    return isValid;\n  }\n}\n\n\nexport const registrationName = 'LineCursor';\nexport const registrationType = Blockly.registry.Type.CURSOR;\n\nBlockly.registry.register(registrationType, registrationName, LineCursor);\n\nexport const pluginInfo = {\n  [registrationType]: registrationName,\n};\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Holds all methods necessary to use Blockly through the\n * keyboard.\n * @author aschmiedt@google.com (Abby Schmiedt)\n */\n\nimport * as Blockly from 'blockly/core';\nimport * as Constants from './constants';\nimport {\n  registrationName as cursorRegistrationName,\n  registrationType as cursorRegistrationType} from './flyout_cursor';\n\n/**\n * Class that holds all methods necessary for keyboard navigation to work.\n */\nexport class Navigation {\n  /**\n   * Constructor for keyboard navigation.\n   */\n  constructor() {\n    /**\n     * Object holding the location of the cursor for each workspace.\n     * Possible locations of the cursor are: workspace, flyout or toolbox.\n     * @type {Object<string,Constants.STATE>}\n     * @protected\n     */\n    this.workspaceStates = {};\n\n    /**\n     * An optional method that allows a developer to customize how to handle\n     * logs, warnings, and errors. The first argument is one of 'log', 'warn',\n     * or 'error'. The second argument is the message.\n     * @type {?function(Constants.LOGGING_MSG_TYPE, string)}\n     * @public\n     */\n    this.loggingCallback = null;\n\n    /**\n     * The distance to move the cursor when the cursor is on the workspace.\n     * @type {number}\n     * @public\n     */\n    this.WS_MOVE_DISTANCE = 40;\n\n    /**\n     * The name of the marker to use for keyboard navigation.\n     * @type {string}\n     * @public\n     */\n    this.MARKER_NAME = 'local_marker_1';\n\n    /**\n     * The default coordinate to use when focusing on the workspace and no\n     * blocks are present. In pixel coordinates, but will be converted to\n     * workspace coordinates when used to position the cursor.\n     * @type {!Blockly.utils.Coordinate}\n     * @public\n     */\n    this.DEFAULT_WS_COORDINATE = new Blockly.utils.Coordinate(100, 100);\n\n    /**\n     * The default coordinate to use when moving the cursor to the workspace\n     * after a block has been deleted. In pixel coordinates, but will be\n     * converted to workspace coordinates when used to position the cursor.\n     * @type {!Blockly.utils.Coordinate}\n     * @public\n     */\n    this.WS_COORDINATE_ON_DELETE = new Blockly.utils.Coordinate(100, 100);\n\n    /**\n     * Wrapper for method that deals with workspace changes.\n     * Used for removing change listener.\n     * @type {Function}\n     * @protected\n     */\n    this.wsChangeWrapper = this.workspaceChangeListener.bind(this);\n\n    /**\n     * Wrapper for method that deals with flyout changes.\n     * Used for removing change listener.\n     * @type {Function}\n     * @protected\n     */\n    this.flyoutChangeWrapper = this.flyoutChangeListener.bind(this);\n\n    /**\n     * The list of registered workspaces.\n     * Used when removing change listeners in dispose.\n     * @type {!Array<!Blockly.WorkspaceSvg>}\n     * @protected\n     */\n    this.workspaces = [];\n  }\n\n  /**\n   * Adds all necessary change listeners and markers to a workspace for keyboard\n   * navigation to work. This must be called for keyboard navigation to work\n   * on a workspace.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace to add keyboard\n   *     navigation to.\n   * @public\n   */\n  addWorkspace(workspace) {\n    this.workspaces.push(workspace);\n    const flyout = workspace.getFlyout();\n    workspace.getMarkerManager().registerMarker(\n        this.MARKER_NAME, new Blockly.Marker());\n    workspace.addChangeListener(this.wsChangeWrapper);\n\n    if (flyout) {\n      this.addFlyout(flyout);\n    }\n  }\n\n  /**\n   * Removes all keyboard navigation change listeners and markers.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace to remove keyboard\n   *     navigation from.\n   * @public\n   */\n  removeWorkspace(workspace) {\n    const workspaceIdx = this.workspaces.indexOf(workspace);\n    const flyout = workspace.getFlyout();\n\n    if (workspace.getCursor()) {\n      this.disableKeyboardAccessibility(workspace);\n    }\n\n    if (workspaceIdx > -1) {\n      this.workspaces.splice(workspaceIdx, 1);\n    }\n    if (workspace.getMarkerManager()) {\n      workspace.getMarkerManager().unregisterMarker(this.MARKER_NAME);\n    }\n    workspace.removeChangeListener(this.wsChangeWrapper);\n\n    if (flyout) {\n      this.removeFlyout(flyout);\n    }\n  }\n\n  /**\n   * Sets the state for the given workspace.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace to set the state on.\n   * @param {!Constants.STATE} state The navigation state.\n   * @protected\n   */\n  setState(workspace, state) {\n    this.workspaceStates[workspace.id] = state;\n  }\n\n  /**\n   * Gets the navigation state of the current workspace.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace to get the state of.\n   * @return {!Constants.STATE} The state of the given workspace.\n   * @package\n   */\n  getState(workspace) {\n    return this.workspaceStates[workspace.id];\n  }\n\n  /**\n   * Gets the marker created for keyboard navigation.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace to get the marker\n   *     from.\n   * @return {?Blockly.Marker} The marker created for keyboard navigation.\n   * @protected\n   */\n  getMarker(workspace) {\n    return workspace.getMarker(this.MARKER_NAME);\n  }\n\n  /**\n   * Adds all event listeners and cursors to the flyout that are needed for\n   * keyboard navigation to work.\n   * @param {!Blockly.IFlyout} flyout The flyout to add a cursor and change\n   *     listeners to.\n   * @protected\n   */\n  addFlyout(flyout) {\n    const flyoutWorkspace = flyout.getWorkspace();\n    flyoutWorkspace.addChangeListener(this.flyoutChangeWrapper);\n    const FlyoutCursorClass = Blockly.registry.getClass(\n        cursorRegistrationType, cursorRegistrationName);\n    flyoutWorkspace.getMarkerManager().setCursor(new FlyoutCursorClass());\n  }\n\n  /**\n   * Removes all change listeners from the flyout that are needed for\n   * keyboard navigation to work.\n   * @param {!Blockly.IFlyout} flyout The flyout to add a cursor and event\n   *     listeners to.\n   * @protected\n   */\n  removeFlyout(flyout) {\n    const flyoutWorkspace = flyout.getWorkspace();\n    flyoutWorkspace.removeChangeListener(this.flyoutChangeWrapper);\n  }\n\n  /**\n   * Updates the state of keyboard navigation and the position of the cursor\n   * based on workspace events.\n   * @param {!Blockly.Events.Abstract} e The Blockly event to process.\n   * @protected\n   */\n  workspaceChangeListener(e) {\n    const workspace = Blockly.Workspace.getById(e.workspaceId);\n    if (!workspace || !workspace.keyboardAccessibilityMode) {\n      return;\n    }\n    switch (e.type) {\n      case Blockly.Events.DELETE:\n        this.handleBlockDeleteByDrag(workspace, e);\n        break;\n      case Blockly.Events.BLOCK_CHANGE:\n        if (e.element === 'mutation') {\n          this.handleBlockMutation(\n              workspace, /** @type {Blockly.Events.BlockChange} */ (e));\n        }\n        break;\n      case Blockly.Events.CLICK:\n        this.handleWorkspaceClick(\n            workspace, /** @type {Blockly.Events.Click} */ (e));\n        break;\n      case Blockly.Events.TOOLBOX_ITEM_SELECT:\n        this.handleToolboxCategoryClick(\n            workspace, /** @type {Blockly.Events.ToolboxItemSelect} */ (e));\n        break;\n      case Blockly.Events.BLOCK_CREATE:\n        this.handleBlockCreate(workspace, e);\n    }\n  }\n\n  /**\n   * Updates the state of keyboard navigation and the position of the cursor\n   * based on events emitted from the flyout's workspace.\n   * @param {!Blockly.Events.Abstract} e The Blockly event to process.\n   * @protected\n   */\n  flyoutChangeListener(e) {\n    const flyoutWorkspace = Blockly.Workspace.getById(e.workspaceId);\n    const mainWorkspace = flyoutWorkspace.targetWorkspace;\n    const flyout = mainWorkspace.getFlyout();\n\n    // This is called for simple toolboxes and for toolboxes that have a flyout\n    // that does not close. Autoclosing flyouts close before we need to focus\n    // the cursor on the block that was clicked.\n    if (mainWorkspace && mainWorkspace.keyboardAccessibilityMode &&\n        !flyout.autoClose) {\n      if ((e.type === Blockly.Events.CLICK && e.targetType === 'block')) {\n        const block = flyoutWorkspace.getBlockById(e.blockId);\n        this.handleBlockClickInFlyout(mainWorkspace, block);\n      } else if (e.type === Blockly.Events.SELECTED) {\n        const block = flyoutWorkspace.getBlockById(e.newElementId);\n        this.handleBlockClickInFlyout(mainWorkspace, block);\n      }\n    }\n  }\n\n  /**\n   * Moves the cursor to the workspace if a block has been dragged from a simple\n   * toolbox. For a category toolbox this is handled in\n   * handleToolboxCategoryClick_.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace the cursor belongs\n   *     to.\n   * @param {!Blockly.Events.Abstract} e The Blockly event to process.\n   * @protected\n   */\n  handleBlockCreate(workspace, e) {\n    if (this.getState(workspace) === Constants.STATE.FLYOUT) {\n      this.resetFlyout(workspace, !!workspace.getToolbox());\n      this.setState(workspace, Constants.STATE.WORKSPACE);\n    }\n  }\n\n  /**\n   * Moves the cursor to the block level when the block the cursor is on\n   * mutates.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace the cursor belongs\n   *     to.\n   * @param {!Blockly.Events.BlockChange} e The Blockly event to process.\n   * @protected\n   */\n  handleBlockMutation(workspace, e) {\n    const mutatedBlockId = e.blockId;\n    const cursor = workspace.getCursor();\n    if (cursor) {\n      const curNode = cursor.getCurNode();\n      const block = curNode ? curNode.getSourceBlock() : null;\n      if (block && block.id === mutatedBlockId) {\n        cursor.setCurNode(Blockly.ASTNode.createBlockNode(block));\n      }\n    }\n  }\n\n  /**\n   * Moves the cursor to the workspace when a user clicks on the workspace.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace the cursor belongs\n   *     to.\n   * @param {!Blockly.Events.Click} e The Blockly event to process.\n   * @protected\n   */\n  handleWorkspaceClick(workspace, e) {\n    const workspaceState = this.getState(workspace);\n    if (workspaceState !== Constants.STATE.WORKSPACE) {\n      this.resetFlyout(workspace, !!workspace.getToolbox());\n      this.setState(workspace, Constants.STATE.WORKSPACE);\n    }\n  }\n\n  /**\n   * Moves the cursor to the toolbox when a user clicks on a toolbox category.\n   * Moves the cursor to the workspace if theh user closes the toolbox category.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace the toolbox is on.\n   * @param {!Blockly.Events.ToolboxItemSelect} e The event emitted from the\n   *     workspace.\n   * @protected\n   */\n  handleToolboxCategoryClick(workspace, e) {\n    const workspaceState = this.getState(workspace);\n    if (e.newItem && workspaceState !== Constants.STATE.TOOLBOX) {\n      // If the toolbox category was just clicked, focus on the toolbox.\n      this.focusToolbox(workspace);\n    } else if (!e.newItem) {\n      // If the toolbox was closed, focus on the workspace.\n      this.resetFlyout(workspace, !!workspace.getToolbox());\n      this.setState(workspace, Constants.STATE.WORKSPACE);\n    }\n  }\n\n  /**\n   * Moves the cursor to the workspace when its parent block is deleted by\n   * being dragged to the flyout or to the trashcan.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace the block was on.\n   * @param {!Blockly.Events.Delete} e The event emitted when a block is\n   *     deleted.\n   * @protected\n   */\n  handleBlockDeleteByDrag(workspace, e) {\n    const deletedBlockId = e.blockId;\n    const ids = e.ids;\n    const cursor = workspace.getCursor();\n\n    // Make sure the cursor is on a block.\n    if (!cursor || !cursor.getCurNode() ||\n        !cursor.getCurNode().getSourceBlock()) {\n      return;\n    }\n\n    const curNode = cursor.getCurNode();\n    const sourceBlock = curNode.getSourceBlock();\n    if (sourceBlock.id === deletedBlockId || ids.indexOf(sourceBlock.id) > -1) {\n      cursor.setCurNode(Blockly.ASTNode.createWorkspaceNode(\n          workspace, this.WS_COORDINATE_ON_DELETE));\n    }\n  }\n\n  /**\n   * Handles when a user clicks on a block in the flyout by moving the cursor\n   * to that stack of blocks and setting the state of navigation to the flyout.\n   * @param {!Blockly.WorkspaceSvg} mainWorkspace The workspace the user clicked\n   *     on.\n   * @param {!Blockly.BlockSvg} block The block the user clicked on.\n   * @protected\n   */\n  handleBlockClickInFlyout(mainWorkspace, block) {\n    if (!block) {\n      return;\n    }\n    if (block.isShadow()) {\n      block = /** @type {Blockly.BlockSvg}*/ (block.getParent());\n    }\n    this.getFlyoutCursor(mainWorkspace)\n        .setCurNode(Blockly.ASTNode.createStackNode(block));\n    this.setState(mainWorkspace, Constants.STATE.FLYOUT);\n  }\n\n  /**\n   * Moves the cursor to the appropriate location before a block is deleted.\n   * This is used when the user deletes a block using the delete or backspace\n   * key.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace the block is being\n   *     deleted on.\n   * @param {!Blockly.BlockSvg} deletedBlock The block that is being deleted.\n   * @package\n   */\n  moveCursorOnBlockDelete(workspace, deletedBlock) {\n    if (!workspace || !workspace.getCursor()) {\n      return;\n    }\n    const cursor = workspace.getCursor();\n    const curNode = cursor.getCurNode();\n    const block = curNode ? curNode.getSourceBlock() : null;\n\n    if (block === deletedBlock) {\n      // If the block has a parent move the cursor to their connection point.\n      if (block.getParent()) {\n        const topConnection =\n            block.previousConnection || block.outputConnection;\n        if (topConnection) {\n          cursor.setCurNode(Blockly.ASTNode.createConnectionNode(\n              topConnection.targetConnection));\n        }\n      } else {\n        // If the block is by itself move the cursor to the workspace.\n        cursor.setCurNode(Blockly.ASTNode.createWorkspaceNode(\n            block.workspace, block.getRelativeToSurfaceXY()));\n      }\n      // If the cursor is on a block whose parent is being deleted, move the\n      // cursor to the workspace.\n    } else if (block && deletedBlock.getChildren(false).indexOf(block) > -1) {\n      cursor.setCurNode(Blockly.ASTNode.createWorkspaceNode(\n          block.workspace, block.getRelativeToSurfaceXY()));\n    }\n  }\n\n  /**\n   * Sets the navigation state to toolbox and selects the first category in the\n   * toolbox. No-op if a toolbox does not exist on the given workspace.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace to get the toolbox\n   *     on.\n   * @package\n   */\n  focusToolbox(workspace) {\n    const toolbox = workspace.getToolbox();\n    if (!toolbox) {\n      return;\n    }\n\n    this.setState(workspace, Constants.STATE.TOOLBOX);\n    this.resetFlyout(workspace, false /* shouldHide */);\n\n    if (!this.getMarker(workspace).getCurNode()) {\n      this.markAtCursor(workspace);\n    }\n\n    if (!toolbox.getSelectedItem()) {\n      // Find the first item that is selectable.\n      const toolboxItems = toolbox.getToolboxItems();\n      for (let i = 0, toolboxItem; (toolboxItem = toolboxItems[i]); i++) {\n        if (toolboxItem.isSelectable()) {\n          toolbox.selectItemByPosition(i);\n          break;\n        }\n      }\n    }\n  }\n\n  /**\n   * Sets the navigation state to flyout and moves the cursor to the first\n   * block in the flyout.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace the flyout is on.\n   * @package\n   */\n  focusFlyout(workspace) {\n    const flyout = workspace.getFlyout();\n\n    this.setState(workspace, Constants.STATE.FLYOUT);\n\n    if (!this.getMarker(workspace).getCurNode()) {\n      this.markAtCursor(workspace);\n    }\n\n    if (flyout && flyout.getWorkspace()) {\n      const topBlocks = flyout.getWorkspace().getTopBlocks(true);\n      if (topBlocks.length > 0) {\n        const astNode = Blockly.ASTNode.createStackNode(topBlocks[0]);\n        this.getFlyoutCursor(workspace).setCurNode(astNode);\n      }\n    }\n  }\n\n  /**\n   * Sets the navigation state to workspace and moves the cursor to either the\n   * top block on a workspace or to the workspace.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace to focus on.\n   * @package\n   */\n  focusWorkspace(workspace) {\n    workspace.hideChaff();\n    const reset = !!workspace.getToolbox();\n\n    this.resetFlyout(workspace, reset);\n    this.setState(workspace, Constants.STATE.WORKSPACE);\n    this.setCursorOnWorkspaceFocus(workspace);\n  }\n\n  /**\n   * Moves the cursor to the top connection point on on the first top block.\n   * If the workspace is empty, moves the cursor to the default location on\n   * the workspace.\n   * @param {!Blockly.WorkspaceSvg} workspace The main Blockly workspace.\n   * @protected\n   */\n  setCursorOnWorkspaceFocus(workspace) {\n    const topBlocks = workspace.getTopBlocks(true);\n    const cursor = workspace.getCursor();\n    const wsCoordinates = new Blockly.utils.Coordinate(\n        this.DEFAULT_WS_COORDINATE.x / workspace.scale,\n        this.DEFAULT_WS_COORDINATE.y / workspace.scale);\n    if (topBlocks.length > 0) {\n      cursor.setCurNode(Blockly.ASTNode.createTopNode(topBlocks[0]));\n    } else {\n      const wsNode =\n          Blockly.ASTNode.createWorkspaceNode(workspace, wsCoordinates);\n      cursor.setCurNode(wsNode);\n    }\n  }\n\n  /**\n   * Gets the cursor on the flyout's workspace.\n   * @param {!Blockly.WorkspaceSvg} workspace The main workspace the flyout is\n   *     on.\n   * @return {?Blockly.FlyoutCursor} The flyout's cursor or null if no flyout\n   *     exists.\n   * @protected\n   */\n  getFlyoutCursor(workspace) {\n    const flyout = workspace.getFlyout();\n    const cursor = flyout ? flyout.getWorkspace().getCursor() : null;\n\n    return /** @type {?Blockly.FlyoutCursor} */ (cursor);\n  }\n\n  /**\n   * Inserts a block from the flyout.\n   * Tries to find a connection on the block to connect to the marked\n   * location. If no connection has been marked, or there is not a compatible\n   * connection then the block is placed on the workspace.\n   * @param {!Blockly.WorkspaceSvg} workspace The main workspace. The workspace\n   *     the block will be placed on.\n   * @package\n   */\n  insertFromFlyout(workspace) {\n    const newBlock = this.createNewBlock(workspace);\n    if (!newBlock) {\n      return;\n    }\n    const markerNode = this.getMarker(workspace).getCurNode();\n    if (!this.tryToConnectMarkerAndCursor(\n        workspace, markerNode, Blockly.ASTNode.createBlockNode(newBlock))) {\n      this.warn(\n          'Something went wrong while inserting a block from the flyout.');\n    }\n\n    this.focusWorkspace(workspace);\n    workspace.getCursor().setCurNode(Blockly.ASTNode.createTopNode(newBlock));\n    this.removeMark(workspace);\n  }\n\n  /**\n   * Creates a new block based on the current block the flyout cursor is on.\n   * @param {!Blockly.WorkspaceSvg} workspace The main workspace. The workspace\n   *     the block will be placed on.\n   * @return {?Blockly.BlockSvg} The newly created block.\n   * @protected\n   */\n  createNewBlock(workspace) {\n    const flyout = workspace.getFlyout();\n    if (!flyout || !flyout.isVisible()) {\n      this.warn(\n          'Trying to insert from the flyout when the flyout does not ' +\n          ' exist or is not visible');\n      return null;\n    }\n\n    const curBlock = /** @type {!Blockly.BlockSvg} */ (\n      this.getFlyoutCursor(workspace).getCurNode().getLocation());\n    if (!curBlock.isEnabled()) {\n      this.warn('Can\\'t insert a disabled block.');\n      return null;\n    }\n\n    const newBlock = flyout.createBlock(curBlock);\n    // Render to get the sizing right.\n    newBlock.render();\n    // Connections are not tracked when the block is first created.  Normally\n    // there's enough time for them to become tracked in the user's mouse\n    // movements, but not here.\n    newBlock.setConnectionTracking(true);\n    return newBlock;\n  }\n\n  /**\n   * Hides the flyout cursor and optionally hides the flyout.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace.\n   * @param {boolean} shouldHide True if the flyout should be hidden.\n   * @protected\n   */\n  resetFlyout(workspace, shouldHide) {\n    if (this.getFlyoutCursor(workspace)) {\n      this.getFlyoutCursor(workspace).hide();\n      if (shouldHide) {\n        workspace.getFlyout().hide();\n      }\n    }\n  }\n\n  /**\n   * Connects the location of the marker and the location of the cursor.\n   * No-op if the marker or cursor node are null.\n   * @param {!Blockly.WorkspaceSvg} workspace The main workspace.\n   * @return {boolean} True if the cursor and marker locations were connected,\n   *     false otherwise.\n   * @package\n   */\n  connectMarkerAndCursor(workspace) {\n    const markerNode = this.getMarker(workspace).getCurNode();\n    const cursorNode = workspace.getCursor().getCurNode();\n\n    if (markerNode && cursorNode) {\n      return this.tryToConnectMarkerAndCursor(\n          workspace, markerNode, cursorNode);\n    }\n    return false;\n  }\n\n  /**\n   * Tries to connect the given marker and cursor node.\n   * @param {!Blockly.WorkspaceSvg} workspace The main workspace.\n   * @param {!Blockly.ASTNode} markerNode The node to try to connect to.\n   * @param {!Blockly.ASTNode} cursorNode The node to connect to the markerNode.\n   * @return {boolean} True if the key was handled; false if something went\n   *     wrong.\n   * @protected\n   */\n  tryToConnectMarkerAndCursor(workspace, markerNode, cursorNode) {\n    if (!this.logConnectionWarning(markerNode, cursorNode)) {\n      return false;\n    }\n\n    const markerType = markerNode.getType();\n    const cursorType = cursorNode.getType();\n\n    const cursorLoc = cursorNode.getLocation();\n    const markerLoc = markerNode.getLocation();\n    if (markerNode.isConnection() && cursorNode.isConnection()) {\n      const cursorConnection =\n      /** @type {!Blockly.RenderedConnection} */ (cursorLoc);\n      const markerConnection =\n      /** @type {!Blockly.RenderedConnection} */ (markerLoc);\n      return this.connect(cursorConnection, markerConnection);\n    } else if (\n      markerNode.isConnection() &&\n        (cursorType == Blockly.ASTNode.types.BLOCK ||\n         cursorType == Blockly.ASTNode.types.STACK)) {\n      const cursorBlock = /** @type {!Blockly.BlockSvg} */ (cursorLoc);\n      const markerConnection =\n      /** @type {!Blockly.RenderedConnection} */ (markerLoc);\n      return this.insertBlock(cursorBlock, markerConnection);\n    } else if (markerType == Blockly.ASTNode.types.WORKSPACE) {\n      const block = cursorNode ? cursorNode.getSourceBlock() : null;\n      return this.moveBlockToWorkspace(\n          /** @type {Blockly.BlockSvg} */ (block), markerNode);\n    }\n    this.warn('Unexpected state in tryToConnectMarkerAndCursor.');\n    return false;\n  }\n\n  /**\n   * Warns the user if the given cursor or marker node can not be connected.\n   * @param {!Blockly.ASTNode} markerNode The node to try to connect to.\n   * @param {!Blockly.ASTNode} cursorNode The node to connect to the markerNode.\n   * @return {boolean} True if the marker and cursor are valid types, false\n   *     otherwise.\n   * @protected\n   */\n  logConnectionWarning(markerNode, cursorNode) {\n    if (!markerNode) {\n      this.warn('Cannot insert with no marked node.');\n      return false;\n    }\n\n    if (!cursorNode) {\n      this.warn('Cannot insert with no cursor node.');\n      return false;\n    }\n    const markerType = markerNode.getType();\n    const cursorType = cursorNode.getType();\n\n    // Check the marker for invalid types.\n    if (markerType == Blockly.ASTNode.types.FIELD) {\n      this.warn('Should not have been able to mark a field.');\n      return false;\n    } else if (markerType == Blockly.ASTNode.types.BLOCK) {\n      this.warn('Should not have been able to mark a block.');\n      return false;\n    } else if (markerType == Blockly.ASTNode.types.STACK) {\n      this.warn('Should not have been able to mark a stack.');\n      return false;\n    }\n\n    // Check the cursor for invalid types.\n    if (cursorType == Blockly.ASTNode.types.FIELD) {\n      this.warn('Cannot attach a field to anything else.');\n      return false;\n    } else if (cursorType == Blockly.ASTNode.types.WORKSPACE) {\n      this.warn('Cannot attach a workspace to anything else.');\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Disconnects the block from its parent and moves it to the position of the\n   * workspace node.\n   * @param {?Blockly.BlockSvg} block The block to be moved to the workspace.\n   * @param {!Blockly.ASTNode} wsNode The workspace node holding the position\n   *     the block will be moved to.\n   * @return {boolean} True if the block can be moved to the workspace,\n   *     false otherwise.\n   * @protected\n   */\n  moveBlockToWorkspace(block, wsNode) {\n    if (!block) {\n      return false;\n    }\n    if (block.isShadow()) {\n      this.warn('Cannot move a shadow block to the workspace.');\n      return false;\n    }\n    if (block.getParent()) {\n      block.unplug(false);\n    }\n    block.moveTo(wsNode.getWsCoordinate());\n    return true;\n  }\n\n  /**\n   * Disconnects the child block from its parent block. No-op if the two given\n   * connections are unrelated.\n   * @param {!Blockly.RenderedConnection} movingConnection The connection that\n   *     is being moved.\n   * @param {!Blockly.RenderedConnection} destConnection The connection to be\n   *     moved to.\n   * @protected\n   */\n  disconnectChild(movingConnection, destConnection) {\n    const movingBlock = movingConnection.getSourceBlock();\n    const destBlock = destConnection.getSourceBlock();\n    let inferiorConnection;\n\n    if (movingBlock.getRootBlock() === destBlock.getRootBlock()) {\n      if (movingBlock.getDescendants(false).indexOf(destBlock) > -1) {\n        inferiorConnection = this.getInferiorConnection(destConnection);\n        if (inferiorConnection) {\n          inferiorConnection.disconnect();\n        }\n      } else {\n        inferiorConnection = this.getInferiorConnection(movingConnection);\n        if (inferiorConnection) {\n          inferiorConnection.disconnect();\n        }\n      }\n    }\n  }\n\n  /**\n   * Tries to connect the  given connections.\n   *\n   * If the given connections are not compatible try finding compatible\n   * connections on the source blocks of the given connections.\n   *\n   * @param {?Blockly.RenderedConnection} movingConnection The connection that\n   *     is being moved.\n   * @param {?Blockly.RenderedConnection} destConnection The connection to be\n   *     moved to.\n   * @return {boolean} True if the two connections or their target connections\n   *     were connected, false otherwise.\n   * @protected\n   */\n  connect(movingConnection, destConnection) {\n    if (!movingConnection || !destConnection) {\n      return false;\n    }\n\n    const movingInferior = this.getInferiorConnection(movingConnection);\n    const destSuperior = this.getSuperiorConnection(destConnection);\n\n    const movingSuperior = this.getSuperiorConnection(movingConnection);\n    const destInferior = this.getInferiorConnection(destConnection);\n\n    if (movingInferior && destSuperior &&\n        this.moveAndConnect(movingInferior, destSuperior)) {\n      return true;\n      // Try swapping the inferior and superior connections on the blocks.\n    } else if (\n      movingSuperior && destInferior &&\n        this.moveAndConnect(movingSuperior, destInferior)) {\n      return true;\n    } else if (this.moveAndConnect(movingConnection, destConnection)) {\n      return true;\n    } else {\n      const checker = movingConnection.getConnectionChecker();\n      const reason =\n          checker.canConnectWithReason(movingConnection, destConnection, false);\n      this.warn(\n          'Connection failed with error: ' +\n          checker.getErrorMessage(reason, movingConnection, destConnection));\n      return false;\n    }\n  }\n\n  /**\n   * Finds the inferior connection on the source block if the given connection\n   * is superior.\n   * @param {?Blockly.RenderedConnection} connection The connection trying to be\n   *     connected.\n   * @return {?Blockly.RenderedConnection} The inferior connection or null if\n   *     none exists.\n   * @protected\n   */\n  getInferiorConnection(connection) {\n    const block = /** @type{!Blockly.BlockSvg} */ (connection.getSourceBlock());\n    if (!connection.isSuperior()) {\n      return connection;\n    } else if (block.previousConnection) {\n      return block.previousConnection;\n    } else if (block.outputConnection) {\n      return block.outputConnection;\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Finds a superior connection on the source block if the given connection is\n   * inferior.\n   * @param {?Blockly.RenderedConnection} connection The connection trying to be\n   *     connected.\n   * @return {?Blockly.RenderedConnection} The superior connection or null if\n   *     none exists.\n   * @protected\n   */\n  getSuperiorConnection(connection) {\n    if (connection.isSuperior()) {\n      return connection;\n    } else if (connection.targetConnection) {\n      return connection.targetConnection;\n    }\n    return null;\n  }\n\n  /**\n   * Moves the moving connection to the target connection and connects them.\n   * @param {?Blockly.RenderedConnection} movingConnection The connection that\n   *     is being moved.\n   * @param {?Blockly.RenderedConnection} destConnection The connection to be\n   *     moved to.\n   * @return {boolean} True if the connections were connected, false otherwise.\n   * @protected\n   */\n  moveAndConnect(movingConnection, destConnection) {\n    if (!movingConnection || !destConnection) {\n      return false;\n    }\n    const movingBlock = movingConnection.getSourceBlock();\n    const checker = movingConnection.getConnectionChecker();\n\n    if (checker.canConnect(movingConnection, destConnection, false) &&\n        !destConnection.getSourceBlock().isShadow()) {\n      this.disconnectChild(movingConnection, destConnection);\n\n      // Position the root block near the connection so it does not move the\n      // other block when they are connected.\n      if (!destConnection.isSuperior()) {\n        const rootBlock = movingBlock.getRootBlock();\n        rootBlock.positionNearConnection(movingConnection, destConnection);\n      }\n      destConnection.connect(movingConnection);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Tries to connect the given block to the destination connection, making an\n   * intelligent guess about which connection to use on the moving block.\n   * @param {!Blockly.BlockSvg} block The block to move.\n   * @param {!Blockly.RenderedConnection} destConnection The connection to\n   *     connect to.\n   * @return {boolean} Whether the connection was successful.\n   * @protected\n   */\n  insertBlock(block, destConnection) {\n    switch (destConnection.type) {\n      case Blockly.PREVIOUS_STATEMENT:\n        if (this.connect(block.nextConnection, destConnection)) {\n          return true;\n        }\n        break;\n      case Blockly.NEXT_STATEMENT:\n        if (this.connect(block.previousConnection, destConnection)) {\n          return true;\n        }\n        break;\n      case Blockly.INPUT_VALUE:\n        if (this.connect(block.outputConnection, destConnection)) {\n          return true;\n        }\n        break;\n      case Blockly.OUTPUT_VALUE:\n        for (let i = 0; i < block.inputList.length; i++) {\n          const inputConnection = /** @type {Blockly.RenderedConnection} */ (\n            block.inputList[i].connection);\n          if (inputConnection && inputConnection.type === Blockly.INPUT_VALUE &&\n              this.connect(inputConnection, destConnection)) {\n            return true;\n          }\n        }\n        // If there are no input values pass the output and destination\n        // connections to connect_ to find a way to connect the two.\n        if (block.outputConnection &&\n            this.connect(block.outputConnection, destConnection)) {\n          return true;\n        }\n        break;\n    }\n    this.warn('This block can not be inserted at the marked location.');\n    return false;\n  }\n\n  /**\n   * Disconnects the connection that the cursor is pointing to, and bump blocks.\n   * This is a no-op if the connection cannot be broken or if the cursor is not\n   * pointing to a connection.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace.\n   * @package\n   */\n  disconnectBlocks(workspace) {\n    const curNode = workspace.getCursor().getCurNode();\n    if (!curNode.isConnection()) {\n      this.log(\n          'Cannot disconnect blocks when the cursor is not on a connection');\n      return;\n    }\n    const curConnection =\n    /** @type {!Blockly.RenderedConnection} */ (curNode.getLocation());\n    if (!curConnection.isConnected()) {\n      this.log('Cannot disconnect unconnected connection');\n      return;\n    }\n    const superiorConnection = curConnection.isSuperior() ?\n        curConnection :\n        curConnection.targetConnection;\n\n    const inferiorConnection = curConnection.isSuperior() ?\n        curConnection.targetConnection :\n        curConnection;\n\n    if (inferiorConnection.getSourceBlock().isShadow()) {\n      this.log('Cannot disconnect a shadow block');\n      return;\n    }\n    superiorConnection.disconnect();\n    inferiorConnection.bumpAwayFrom(superiorConnection);\n\n    const rootBlock = superiorConnection.getSourceBlock().getRootBlock();\n    rootBlock.bringToFront();\n\n    const connectionNode =\n        Blockly.ASTNode.createConnectionNode(superiorConnection);\n    workspace.getCursor().setCurNode(connectionNode);\n  }\n\n  /**\n   * Moves the marker to the cursor's current location.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace.\n   * @protected\n   */\n  markAtCursor(workspace) {\n    this.getMarker(workspace).setCurNode(workspace.getCursor().getCurNode());\n  }\n\n  /**\n   * Removes the marker from its current location and hide it.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace.\n   * @protected\n   */\n  removeMark(workspace) {\n    const marker = this.getMarker(workspace);\n    marker.setCurNode(null);\n    marker.hide();\n  }\n\n  /**\n   * Enables accessibility mode.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace to enable keyboard\n   *     accessibility mode on.\n   * @package\n   */\n  enableKeyboardAccessibility(workspace) {\n    if (this.workspaces.indexOf(workspace) > -1 &&\n        !workspace.keyboardAccessibilityMode) {\n      workspace.keyboardAccessibilityMode = true;\n      this.focusWorkspace(workspace);\n    }\n  }\n\n  /**\n   * Disables accessibility mode.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace to disable keyboard\n   *     accessibility mode on.\n   * @package\n   */\n  disableKeyboardAccessibility(workspace) {\n    if (this.workspaces.indexOf(workspace) > -1 &&\n        workspace.keyboardAccessibilityMode) {\n      workspace.keyboardAccessibilityMode = false;\n      workspace.getCursor().hide();\n      this.getMarker(workspace).hide();\n      if (this.getFlyoutCursor(workspace)) {\n        this.getFlyoutCursor(workspace).hide();\n      }\n    }\n  }\n\n  /**\n   * Navigation log handler. If loggingCallback is defined, use it.\n   * Otherwise just log to the console.log.\n   * @param {string} msg The message to log.\n   * @protected\n   */\n  log(msg) {\n    if (this.loggingCallback) {\n      this.loggingCallback(Constants.LOGGING_MSG_TYPE.LOG, msg);\n    } else {\n      console.log(msg);\n    }\n  }\n\n  /**\n   * Navigation warning handler. If loggingCallback is defined, use it.\n   * Otherwise call console.warn.\n   * @param {string} msg The warning message.\n   * @protected\n   */\n  warn(msg) {\n    if (this.loggingCallback) {\n      this.loggingCallback(Constants.LOGGING_MSG_TYPE.WARN, msg);\n    } else {\n      console.warn(msg);\n    }\n  }\n\n  /**\n   * Navigation error handler. If loggingCallback is defined, use it.\n   * Otherwise call console.error.\n   * @param {string} msg The error message.\n   * @protected\n   */\n  error(msg) {\n    if (this.loggingCallback) {\n      this.loggingCallback(Constants.LOGGING_MSG_TYPE.ERROR, msg);\n    } else {\n      console.error(msg);\n    }\n  }\n\n  /**\n   * Moves the workspace cursor in the given direction.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace the cursor is on.\n   * @param {number} xDirection -1 to move cursor left. 1 to move cursor right.\n   * @param {number} yDirection -1 to move cursor up. 1 to move cursor down.\n   * @return {boolean} True if the current node is a workspace, false otherwise.\n   * @package\n   */\n  moveWSCursor(workspace, xDirection, yDirection) {\n    const cursor = workspace.getCursor();\n    const curNode = workspace.getCursor().getCurNode();\n\n    if (curNode.getType() !== Blockly.ASTNode.types.WORKSPACE) {\n      return false;\n    }\n\n    const wsCoord = curNode.getWsCoordinate();\n    const newX = xDirection * this.WS_MOVE_DISTANCE + wsCoord.x;\n    const newY = yDirection * this.WS_MOVE_DISTANCE + wsCoord.y;\n\n    cursor.setCurNode(Blockly.ASTNode.createWorkspaceNode(\n        workspace, new Blockly.utils.Coordinate(newX, newY)));\n    return true;\n  }\n\n  /**\n   * Handles hitting the enter key on the workspace.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace.\n   * @package\n   */\n  handleEnterForWS(workspace) {\n    const cursor = workspace.getCursor();\n    const curNode = cursor.getCurNode();\n    const nodeType = curNode.getType();\n    if (nodeType == Blockly.ASTNode.types.FIELD) {\n      (/** @type {!Blockly.Field} */ (curNode.getLocation())).showEditor();\n    } else if (\n      curNode.isConnection() || nodeType == Blockly.ASTNode.types.WORKSPACE) {\n      this.markAtCursor(workspace);\n    } else if (nodeType == Blockly.ASTNode.types.BLOCK) {\n      this.warn('Cannot mark a block.');\n    } else if (nodeType == Blockly.ASTNode.types.STACK) {\n      this.warn('Cannot mark a stack.');\n    }\n  }\n\n  /**\n   * Pastes the coped block to the marked location.\n   * @return {boolean} True if the paste was sucessful, false otherwise.\n   * @package\n   */\n  paste() {\n    let isHandled = false;\n    Blockly.Events.setGroup(true);\n    const block = Blockly.clipboard.paste();\n    if (block) {\n      isHandled = this.insertPastedBlock(block.workspace, block);\n    }\n    Blockly.Events.setGroup(false);\n    return isHandled;\n  }\n\n  /**\n   * Inserts the pasted block at the marked location if a compatible connection\n   * exists. If no connection has been marked, or there is not a compatible\n   * connection then the block is placed on the workspace.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace to paste the block\n   *     on.\n   * @param {!Blockly.BlockSvg} block The block to paste.\n   * @return {boolean} True if the block was pasted to the workspace, false\n   *     otherwise.\n   * @protected\n   */\n  insertPastedBlock(workspace, block) {\n    let isHandled = false;\n    const markedNode = workspace.getMarker(this.MARKER_NAME).getCurNode();\n    if (markedNode) {\n      isHandled = this.tryToConnectMarkerAndCursor(\n          workspace, markedNode, Blockly.ASTNode.createBlockNode(block));\n    }\n    return isHandled;\n  }\n\n  /**\n   * Removes the change listeners on all registered workspaces.\n   * @package\n   */\n  dispose() {\n    for (const workspace of this.workspaces) {\n      this.removeWorkspace(workspace);\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Overrides methods on Blockly.Gesture in order to allow users\n * to move the cursor to blocks or the workspace using shift click.\n * TODO(google/blockly#4584): We do not have a way to do this currently without\n * monkey patching Blockly.\n * @author aschmiedt@google.com (Abby Schmiedt)\n */\n\nimport * as Blockly from 'blockly/core';\n\n\nconst oldDoWorkspaceClick = Blockly.Gesture.prototype.doWorkspaceClick_;\n\n/**\n * Execute a workspace click. When in accessibility mode shift clicking will\n * move the cursor.\n * @param {!Event} e A mouse up or touch end event.\n * @this {Blockly.Gesture}\n * @override\n */\nBlockly.Gesture.prototype.doWorkspaceClick_ = function(e) {\n  oldDoWorkspaceClick.call(this, e);\n  const ws = this.creatorWorkspace_;\n  if (e.shiftKey && ws.keyboardAccessibilityMode) {\n    const screenCoord = new Blockly.utils.Coordinate(e.clientX, e.clientY);\n    const wsCoord =\n        Blockly.utils.svgMath.screenToWsCoordinates(ws, screenCoord);\n    const wsNode = Blockly.ASTNode.createWorkspaceNode(ws, wsCoord);\n    ws.getCursor().setCurNode(wsNode);\n  }\n};\n\nconst oldDoBlockClick = Blockly.Gesture.prototype.doBlockClick_;\n\n/**\n * Execute a block click. When in accessibility mode shift clicking will move\n * the cursor to the block.\n * @this {Blockly.Gesture}\n * @override\n */\nBlockly.Gesture.prototype.doBlockClick_ = function(e) {\n  oldDoBlockClick.call(this, e);\n  if (!this.targetBlock_.isInFlyout && this.mostRecentEvent_.shiftKey &&\n      this.targetBlock_.workspace.keyboardAccessibilityMode) {\n    this.creatorWorkspace_.getCursor().setCurNode(\n        Blockly.ASTNode.createTopNode(this.targetBlock_));\n  }\n};\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Registers all of the keyboard shortcuts that are necessary for\n * navigating blockly using the keyboard.\n * @author aschmiedt@google.com (Abby Schmiedt)\n */\n\nimport './gesture_monkey_patch';\n\nimport * as Blockly from 'blockly/core';\n\nimport * as Constants from './constants';\nimport {Navigation} from './navigation';\n\n/**\n * Class for registering shortcuts for keyboard navigation.\n */\nexport class NavigationController {\n  /**\n   * Constructor used for registering shortcuts.\n   * This will register any default shortcuts for keyboard navigation.\n   * This is intended to be a singleton.\n   * @param {!Navigation=} optNavigation The class that handles keyboard\n   *     navigation shortcuts. (Ex: inserting a block, focusing the flyout).\n   */\n  constructor(optNavigation) {\n    /**\n     * Handles any keyboard navigation shortcuts.\n     * @type {!Navigation}\n     * @public\n     */\n    this.navigation = optNavigation || new Navigation();\n  }\n\n  /**\n   * Registers the default keyboard shortcuts for keyboard navigation.\n   * @public\n   */\n  init() {\n    this.addShortcutHandlers();\n    this.registerDefaults();\n  }\n\n  /**\n   * Adds methods to core Blockly components that allows them to handle keyboard\n   * shortcuts when in keyboard navigation mode.\n   * @protected\n   */\n  addShortcutHandlers() {\n    if (Blockly.FieldColour) {\n      Blockly.FieldColour.prototype.onShortcut = this.fieldColourHandler;\n    }\n\n    if (Blockly.FieldDropdown) {\n      Blockly.FieldDropdown.prototype.onShortcut = this.fieldDropdownHandler;\n    }\n\n    if (Blockly.Toolbox) {\n      Blockly.Toolbox.prototype.onShortcut = this.toolboxHandler;\n    }\n  }\n\n  /**\n   * Removes methods on core Blockly components that allows them to handle\n   * keyboard shortcuts.\n   * @protected\n   */\n  removeShortcutHandlers() {\n    if (Blockly.FieldColour) {\n      Blockly.FieldColour.prototype.onShortcut = null;\n    }\n\n    if (Blockly.FieldDropdown) {\n      Blockly.FieldDropdown.prototype.onShortcut = null;\n    }\n\n    if (Blockly.Toolbox) {\n      Blockly.Toolbox.prototype.onShortcut = null;\n    }\n  }\n\n  /**\n   * Handles the given keyboard shortcut.\n   * This is only triggered when keyboard accessibility mode is enabled.\n   * @param {!Blockly.ShortcutRegistry.KeyboardShortcut} shortcut The shortcut\n   *     to be handled.\n   * @return {boolean} True if the field handled the shortcut,\n   *     false otherwise.\n   * @this {Blockly.FieldColour}\n   * @protected\n   */\n  fieldColourHandler(shortcut) {\n    if (this.picker_) {\n      switch (shortcut.name) {\n        case Constants.SHORTCUT_NAMES.PREVIOUS:\n          this.moveHighlightBy_(0, -1);\n          return true;\n        case Constants.SHORTCUT_NAMES.NEXT:\n          this.moveHighlightBy_(0, 1);\n          return true;\n        case Constants.SHORTCUT_NAMES.OUT:\n          this.moveHighlightBy_(-1, 0);\n          return true;\n        case Constants.SHORTCUT_NAMES.IN:\n          this.moveHighlightBy_(1, 0);\n          return true;\n        default:\n          return false;\n      }\n    }\n    return Blockly.FieldColour.superClass_.onShortcut.call(this, shortcut);\n  }\n\n  /**\n   * Handles the given keyboard shortcut.\n   * This is only triggered when keyboard accessibility mode is enabled.\n   * @param {!Blockly.ShortcutRegistry.KeyboardShortcut} shortcut The shortcut\n   *     to be handled.\n   * @return {boolean} True if the field handled the shortcut,\n   *     false otherwise.\n   * @this {Blockly.FieldDropdown}\n   * @protected\n   */\n  fieldDropdownHandler(shortcut) {\n    if (this.menu_) {\n      switch (shortcut.name) {\n        case Constants.SHORTCUT_NAMES.PREVIOUS:\n          this.menu_.highlightPrevious();\n          return true;\n        case Constants.SHORTCUT_NAMES.NEXT:\n          this.menu_.highlightNext();\n          return true;\n        default:\n          return false;\n      }\n    }\n    return Blockly.FieldDropdown.superClass_.onShortcut.call(this, shortcut);\n  }\n\n  /**\n   * Handles the given keyboard shortcut.\n   * This is only triggered when keyboard accessibility mode is enabled.\n   * @param {!Blockly.ShortcutRegistry.KeyboardShortcut} shortcut The shortcut\n   *     to be handled.\n   * @return {boolean} True if the toolbox handled the shortcut,\n   *     false otherwise.\n   * @this {Blockly.Toolbox}\n   * @protected\n   */\n  toolboxHandler(shortcut) {\n    if (!this.selectedItem_) {\n      return false;\n    }\n    switch (shortcut.name) {\n      case Constants.SHORTCUT_NAMES.PREVIOUS:\n        return this.selectPrevious_();\n      case Constants.SHORTCUT_NAMES.OUT:\n        return this.selectParent_();\n      case Constants.SHORTCUT_NAMES.NEXT:\n        return this.selectNext_();\n      case Constants.SHORTCUT_NAMES.IN:\n        return this.selectChild_();\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * Adds all necessary event listeners and markers to a workspace for keyboard\n   * navigation to work. This must be called for keyboard navigation to work\n   * on a workspace.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace to add keyboard\n   *     navigation to.\n   * @public\n   */\n  addWorkspace(workspace) {\n    this.navigation.addWorkspace(workspace);\n  }\n\n  /**\n   * Removes all necessary event listeners and markers to a workspace for\n   * keyboard navigation to work.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace to remove keyboard\n   *     navigation from.\n   * @public\n   */\n  removeWorkspace(workspace) {\n    this.navigation.removeWorkspace(workspace);\n  }\n\n  /**\n   * Turns on keyboard navigation.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace to turn on keyboard\n   *     navigation for.\n   * @public\n   */\n  enable(workspace) {\n    this.navigation.enableKeyboardAccessibility(workspace);\n  }\n\n  /**\n   * Turns off keyboard navigation.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace to turn off keyboard\n   *     navigation on.\n   * @public\n   */\n  disable(workspace) {\n    this.navigation.disableKeyboardAccessibility(workspace);\n  }\n\n  /**\n   * Gives the cursor to the field to handle if the cursor is on a field.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace to check.\n   * @param {!Blockly.ShortcutRegistry.KeyboardShortcut} shortcut The shortcut\n   *     to give to the field.\n   * @return {boolean} True if the shortcut was handled by the field, false\n   *     otherwise.\n   * @protected\n   */\n  fieldShortcutHandler(workspace, shortcut) {\n    const cursor = workspace.getCursor();\n    if (!cursor || !cursor.getCurNode()) {\n      return;\n    }\n    const curNode = cursor.getCurNode();\n    if (curNode.getType() === Blockly.ASTNode.types.FIELD) {\n      return (/** @type {!Blockly.Field} */ (curNode.getLocation()))\n          .onShortcut(shortcut);\n    }\n    return false;\n  }\n\n  /**\n   * Keyboard shortcut to go to the previous location when in keyboard\n   * navigation mode.\n   * @protected\n   */\n  registerPrevious() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const previousShortcut = {\n      name: Constants.SHORTCUT_NAMES.PREVIOUS,\n      preconditionFn: (workspace) => {\n        return workspace.keyboardAccessibilityMode;\n      },\n      callback: (workspace, e, shortcut) => {\n        const flyout = workspace.getFlyout();\n        const toolbox = workspace.getToolbox();\n        let isHandled = false;\n        switch (this.navigation.getState(workspace)) {\n          case Constants.STATE.WORKSPACE:\n            isHandled = this.fieldShortcutHandler(workspace, shortcut);\n            if (!isHandled) {\n              workspace.getCursor().prev();\n              isHandled = true;\n            }\n            return isHandled;\n          case Constants.STATE.FLYOUT:\n            isHandled = this.fieldShortcutHandler(workspace, shortcut);\n            if (!isHandled) {\n              flyout.getWorkspace().getCursor().prev();\n              isHandled = true;\n            }\n            return isHandled;\n          case Constants.STATE.TOOLBOX:\n            return toolbox && typeof toolbox.onShortcut == 'function' ?\n                toolbox.onShortcut(shortcut) :\n                false;\n          default:\n            return false;\n        }\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(previousShortcut);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n        Blockly.utils.KeyCodes.W, previousShortcut.name);\n  }\n\n  /**\n   * Keyboard shortcut to turn keyboard navigation on or off.\n   * @protected\n   */\n  registerToggleKeyboardNav() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const toggleKeyboardNavShortcut = {\n      name: Constants.SHORTCUT_NAMES.TOGGLE_KEYBOARD_NAV,\n      callback: (workspace) => {\n        if (workspace.keyboardAccessibilityMode) {\n          this.navigation.disableKeyboardAccessibility(workspace);\n        } else {\n          this.navigation.enableKeyboardAccessibility(workspace);\n        }\n        return true;\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(toggleKeyboardNavShortcut);\n    const ctrlShiftK = Blockly.ShortcutRegistry.registry.createSerializedKey(\n        Blockly.utils.KeyCodes.K,\n        [Blockly.utils.KeyCodes.CTRL, Blockly.utils.KeyCodes.SHIFT]);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n        ctrlShiftK, toggleKeyboardNavShortcut.name);\n  }\n\n  /**\n   * Keyboard shortcut to go to the out location when in keyboard navigation\n   * mode.\n   * @protected\n   */\n  registerOut() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const outShortcut = {\n      name: Constants.SHORTCUT_NAMES.OUT,\n      preconditionFn: (workspace) => {\n        return workspace.keyboardAccessibilityMode;\n      },\n      callback: (workspace, e, shortcut) => {\n        const toolbox = workspace.getToolbox();\n        let isHandled = false;\n        switch (this.navigation.getState(workspace)) {\n          case Constants.STATE.WORKSPACE:\n            isHandled = this.fieldShortcutHandler(workspace, shortcut);\n            if (!isHandled) {\n              workspace.getCursor().out();\n              isHandled = true;\n            }\n            return isHandled;\n          case Constants.STATE.FLYOUT:\n            this.navigation.focusToolbox(workspace);\n            return true;\n          case Constants.STATE.TOOLBOX:\n            return toolbox && typeof toolbox.onShortcut == 'function' ?\n                toolbox.onShortcut(shortcut) :\n                false;\n          default:\n            return false;\n        }\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(outShortcut);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n        Blockly.utils.KeyCodes.A, outShortcut.name);\n  }\n\n  /**\n   * Keyboard shortcut to go to the next location when in keyboard navigation\n   * mode.\n   * @protected\n   */\n  registerNext() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const nextShortcut = {\n      name: Constants.SHORTCUT_NAMES.NEXT,\n      preconditionFn: (workspace) => {\n        return workspace.keyboardAccessibilityMode;\n      },\n      callback: (workspace, e, shortcut) => {\n        const toolbox = workspace.getToolbox();\n        const flyout = workspace.getFlyout();\n        let isHandled = false;\n        switch (this.navigation.getState(workspace)) {\n          case Constants.STATE.WORKSPACE:\n            isHandled = this.fieldShortcutHandler(workspace, shortcut);\n            if (!isHandled) {\n              workspace.getCursor().next();\n              isHandled = true;\n            }\n            return isHandled;\n          case Constants.STATE.FLYOUT:\n            isHandled = this.fieldShortcutHandler(workspace, shortcut);\n            if (!isHandled) {\n              flyout.getWorkspace().getCursor().next();\n              isHandled = true;\n            }\n            return isHandled;\n          case Constants.STATE.TOOLBOX:\n            return toolbox && typeof toolbox.onShortcut == 'function' ?\n                toolbox.onShortcut(shortcut) :\n                false;\n          default:\n            return false;\n        }\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(nextShortcut);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n        Blockly.utils.KeyCodes.S, nextShortcut.name);\n  }\n\n  /**\n   * Keyboard shortcut to go to the in location when in keyboard navigation\n   * mode.\n   * @protected\n   */\n  registerIn() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const inShortcut = {\n      name: Constants.SHORTCUT_NAMES.IN,\n      preconditionFn: (workspace) => {\n        return workspace.keyboardAccessibilityMode;\n      },\n      callback: (workspace, e, shortcut) => {\n        const toolbox = workspace.getToolbox();\n        let isHandled = false;\n        switch (this.navigation.getState(workspace)) {\n          case Constants.STATE.WORKSPACE:\n            isHandled = this.fieldShortcutHandler(workspace, shortcut);\n            if (!isHandled) {\n              workspace.getCursor().in();\n              isHandled = true;\n            }\n            return isHandled;\n          case Constants.STATE.TOOLBOX:\n            isHandled = toolbox && typeof toolbox.onShortcut == 'function' ?\n                toolbox.onShortcut(shortcut) :\n                false;\n            if (!isHandled) {\n              this.navigation.focusFlyout(workspace);\n            }\n            return true;\n          default:\n            return false;\n        }\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(inShortcut);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n        Blockly.utils.KeyCodes.D, inShortcut.name);\n  }\n\n  /**\n   * Keyboard shortcut to connect a block to a marked location when in keyboard\n   * navigation mode.\n   * @protected\n   */\n  registerInsert() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const insertShortcut = {\n      name: Constants.SHORTCUT_NAMES.INSERT,\n      preconditionFn: (workspace) => {\n        return workspace.keyboardAccessibilityMode &&\n            !workspace.options.readOnly;\n      },\n      callback: (workspace) => {\n        switch (this.navigation.getState(workspace)) {\n          case Constants.STATE.WORKSPACE:\n            return this.navigation.connectMarkerAndCursor(workspace);\n          default:\n            return false;\n        }\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(insertShortcut);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n        Blockly.utils.KeyCodes.I, insertShortcut.name);\n  }\n\n  /**\n   * Keyboard shortcut to mark a location when in keyboard navigation mode.\n   * @protected\n   */\n  registerMark() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const markShortcut = {\n      name: Constants.SHORTCUT_NAMES.MARK,\n      preconditionFn: (workspace) => {\n        return workspace.keyboardAccessibilityMode &&\n            !workspace.options.readOnly;\n      },\n      callback: (workspace) => {\n        switch (this.navigation.getState(workspace)) {\n          case Constants.STATE.WORKSPACE:\n            this.navigation.handleEnterForWS(workspace);\n            return true;\n          case Constants.STATE.FLYOUT:\n            this.navigation.insertFromFlyout(workspace);\n            return true;\n          default:\n            return false;\n        }\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(markShortcut);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n        Blockly.utils.KeyCodes.ENTER, markShortcut.name);\n  }\n\n  /**\n   * Keyboard shortcut to disconnect two blocks when in keyboard navigation\n   * mode.\n   * @protected\n   */\n  registerDisconnect() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const disconnectShortcut = {\n      name: Constants.SHORTCUT_NAMES.DISCONNECT,\n      preconditionFn: (workspace) => {\n        return workspace.keyboardAccessibilityMode &&\n            !workspace.options.readOnly;\n      },\n      callback: (workspace) => {\n        switch (this.navigation.getState(workspace)) {\n          case Constants.STATE.WORKSPACE:\n            this.navigation.disconnectBlocks(workspace);\n            return true;\n          default:\n            return false;\n        }\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(disconnectShortcut);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n        Blockly.utils.KeyCodes.X, disconnectShortcut.name);\n  }\n\n  /**\n   * Keyboard shortcut to focus on the toolbox when in keyboard navigation\n   * mode.\n   * @protected\n   */\n  registerToolboxFocus() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const focusToolboxShortcut = {\n      name: Constants.SHORTCUT_NAMES.TOOLBOX,\n      preconditionFn: (workspace) => {\n        return workspace.keyboardAccessibilityMode &&\n            !workspace.options.readOnly;\n      },\n      callback: (workspace) => {\n        switch (this.navigation.getState(workspace)) {\n          case Constants.STATE.WORKSPACE:\n            if (!workspace.getToolbox()) {\n              this.navigation.focusFlyout(workspace);\n            } else {\n              this.navigation.focusToolbox(workspace);\n            }\n            return true;\n          default:\n            return false;\n        }\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(focusToolboxShortcut);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n        Blockly.utils.KeyCodes.T, focusToolboxShortcut.name);\n  }\n\n  /**\n   * Keyboard shortcut to exit the current location and focus on the workspace\n   * when in keyboard navigation mode.\n   * @protected\n   */\n  registerExit() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const exitShortcut = {\n      name: Constants.SHORTCUT_NAMES.EXIT,\n      preconditionFn: (workspace) => {\n        return workspace.keyboardAccessibilityMode;\n      },\n      callback: (workspace) => {\n        switch (this.navigation.getState(workspace)) {\n          case Constants.STATE.FLYOUT:\n            this.navigation.focusWorkspace(workspace);\n            return true;\n          case Constants.STATE.TOOLBOX:\n            this.navigation.focusWorkspace(workspace);\n            return true;\n          default:\n            return false;\n        }\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(exitShortcut, true);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n        Blockly.utils.KeyCodes.ESC, exitShortcut.name, true);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n        Blockly.utils.KeyCodes.E, exitShortcut.name, true);\n  }\n\n  /**\n   * Keyboard shortcut to move the cursor on the workspace to the left when in\n   * keyboard navigation mode.\n   * @protected\n   */\n  registerWorkspaceMoveLeft() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const wsMoveLeftShortcut = {\n      name: Constants.SHORTCUT_NAMES.MOVE_WS_CURSOR_LEFT,\n      preconditionFn: (workspace) => {\n        return workspace.keyboardAccessibilityMode &&\n            !workspace.options.readOnly;\n      },\n      callback: (workspace) => {\n        return this.navigation.moveWSCursor(workspace, -1, 0);\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(wsMoveLeftShortcut);\n    const shiftA = Blockly.ShortcutRegistry.registry.createSerializedKey(\n        Blockly.utils.KeyCodes.A, [Blockly.utils.KeyCodes.SHIFT]);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n        shiftA, wsMoveLeftShortcut.name);\n  }\n\n  /**\n   * Keyboard shortcut to move the cursor on the workspace to the right when in\n   * keyboard navigation mode.\n   * @protected\n   */\n  registerWorkspaceMoveRight() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const wsMoveRightShortcut = {\n      name: Constants.SHORTCUT_NAMES.MOVE_WS_CURSOR_RIGHT,\n      preconditionFn: (workspace) => {\n        return workspace.keyboardAccessibilityMode &&\n            !workspace.options.readOnly;\n      },\n      callback: (workspace) => {\n        return this.navigation.moveWSCursor(workspace, 1, 0);\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(wsMoveRightShortcut);\n    const shiftD = Blockly.ShortcutRegistry.registry.createSerializedKey(\n        Blockly.utils.KeyCodes.D, [Blockly.utils.KeyCodes.SHIFT]);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n        shiftD, wsMoveRightShortcut.name);\n  }\n\n  /**\n   * Keyboard shortcut to move the cursor on the workspace up when in keyboard\n   * navigation mode.\n   * @protected\n   */\n  registerWorkspaceMoveUp() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const wsMoveUpShortcut = {\n      name: Constants.SHORTCUT_NAMES.MOVE_WS_CURSOR_UP,\n      preconditionFn: (workspace) => {\n        return workspace.keyboardAccessibilityMode &&\n            !workspace.options.readOnly;\n      },\n      callback: (workspace) => {\n        return this.navigation.moveWSCursor(workspace, 0, -1);\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(wsMoveUpShortcut);\n    const shiftW = Blockly.ShortcutRegistry.registry.createSerializedKey(\n        Blockly.utils.KeyCodes.W, [Blockly.utils.KeyCodes.SHIFT]);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n        shiftW, wsMoveUpShortcut.name);\n  }\n\n  /**\n   * Keyboard shortcut to move the cursor on the workspace down when in\n   * keyboard navigation mode.\n   * @protected\n   */\n  registerWorkspaceMoveDown() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const wsMoveDownShortcut = {\n      name: Constants.SHORTCUT_NAMES.MOVE_WS_CURSOR_DOWN,\n      preconditionFn: (workspace) => {\n        return workspace.keyboardAccessibilityMode &&\n            !workspace.options.readOnly;\n      },\n      callback: (workspace) => {\n        return this.navigation.moveWSCursor(workspace, 0, 1);\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(wsMoveDownShortcut);\n    const shiftW = Blockly.ShortcutRegistry.registry.createSerializedKey(\n        Blockly.utils.KeyCodes.S, [Blockly.utils.KeyCodes.SHIFT]);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n        shiftW, wsMoveDownShortcut.name);\n  }\n\n  /**\n   * Keyboard shortcut to copy the block the cursor is currently on.\n   * @protected\n   */\n  registerCopy() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const copyShortcut = {\n      name: Constants.SHORTCUT_NAMES.COPY,\n      preconditionFn: (workspace) => {\n        if (workspace.keyboardAccessibilityMode &&\n            !workspace.options.readOnly) {\n          const curNode = workspace.getCursor().getCurNode();\n          if (curNode && curNode.getSourceBlock()) {\n            const sourceBlock = curNode.getSourceBlock();\n            return !Blockly.Gesture.inProgress() && sourceBlock &&\n                sourceBlock.isDeletable() && sourceBlock.isMovable();\n          }\n        }\n        return false;\n      },\n      callback: (workspace) => {\n        const sourceBlock = workspace.getCursor().getCurNode().getSourceBlock();\n        workspace.hideChaff();\n        Blockly.clipboard.copy(sourceBlock);\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(copyShortcut);\n\n    const ctrlC = Blockly.ShortcutRegistry.registry.createSerializedKey(\n        Blockly.utils.KeyCodes.C, [Blockly.utils.KeyCodes.CTRL]);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n        ctrlC, copyShortcut.name, true);\n\n    const altC = Blockly.ShortcutRegistry.registry.createSerializedKey(\n        Blockly.utils.KeyCodes.C, [Blockly.utils.KeyCodes.ALT]);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n        altC, copyShortcut.name, true);\n\n    const metaC = Blockly.ShortcutRegistry.registry.createSerializedKey(\n        Blockly.utils.KeyCodes.C, [Blockly.utils.KeyCodes.META]);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n        metaC, copyShortcut.name, true);\n  }\n\n  /**\n   * Register shortcut to paste the copied block to the marked location.\n   * @protected\n   */\n  registerPaste() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const pasteShortcut = {\n      name: Constants.SHORTCUT_NAMES.PASTE,\n      preconditionFn: (workspace) => {\n        return workspace.keyboardAccessibilityMode &&\n            !workspace.options.readOnly && !Blockly.Gesture.inProgress();\n      },\n      callback: () => {\n        return this.navigation.paste();\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(pasteShortcut);\n\n    const ctrlV = Blockly.ShortcutRegistry.registry.createSerializedKey(\n        Blockly.utils.KeyCodes.V, [Blockly.utils.KeyCodes.CTRL]);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n        ctrlV, pasteShortcut.name, true);\n\n    const altV = Blockly.ShortcutRegistry.registry.createSerializedKey(\n        Blockly.utils.KeyCodes.V, [Blockly.utils.KeyCodes.ALT]);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n        altV, pasteShortcut.name, true);\n\n    const metaV = Blockly.ShortcutRegistry.registry.createSerializedKey(\n        Blockly.utils.KeyCodes.V, [Blockly.utils.KeyCodes.META]);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n        metaV, pasteShortcut.name, true);\n  }\n\n  /**\n   * Keyboard shortcut to copy and delete the block the cursor is on using\n   * ctrl+x, cmd+x, or alt+x.\n   * @protected\n   */\n  registerCut() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const cutShortcut = {\n      name: Constants.SHORTCUT_NAMES.CUT,\n      preconditionFn: (workspace) => {\n        if (workspace.keyboardAccessibilityMode &&\n            !workspace.options.readOnly) {\n          const curNode = workspace.getCursor().getCurNode();\n          if (curNode && curNode.getSourceBlock()) {\n            const sourceBlock = curNode.getSourceBlock();\n            return !Blockly.Gesture.inProgress() && sourceBlock &&\n                sourceBlock.isDeletable() && sourceBlock.isMovable() &&\n                !sourceBlock.workspace.isFlyout;\n          }\n        }\n        return false;\n      },\n      callback: (workspace) => {\n        const sourceBlock = workspace.getCursor().getCurNode().getSourceBlock();\n        Blockly.clipboard.copy(sourceBlock);\n        this.navigation.moveCursorOnBlockDelete(workspace, sourceBlock);\n        sourceBlock.checkAndDelete();\n        return true;\n      },\n    };\n\n    Blockly.ShortcutRegistry.registry.register(cutShortcut);\n\n    const ctrlX = Blockly.ShortcutRegistry.registry.createSerializedKey(\n        Blockly.utils.KeyCodes.X, [Blockly.utils.KeyCodes.CTRL]);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n        ctrlX, cutShortcut.name, true);\n\n    const altX = Blockly.ShortcutRegistry.registry.createSerializedKey(\n        Blockly.utils.KeyCodes.X, [Blockly.utils.KeyCodes.ALT]);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n        altX, cutShortcut.name, true);\n\n    const metaX = Blockly.ShortcutRegistry.registry.createSerializedKey(\n        Blockly.utils.KeyCodes.X, [Blockly.utils.KeyCodes.META]);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n        metaX, cutShortcut.name, true);\n  }\n\n  /**\n   * Registers shortcut to delete the block the cursor is on using delete or\n   * backspace.\n   * @protected\n   */\n  registerDelete() {\n    /** @type {!Blockly.ShortcutRegistry.KeyboardShortcut} */\n    const deleteShortcut = {\n      name: Constants.SHORTCUT_NAMES.DELETE,\n      preconditionFn: function(workspace) {\n        if (workspace.keyboardAccessibilityMode &&\n            !workspace.options.readOnly) {\n          const curNode = workspace.getCursor().getCurNode();\n          if (curNode && curNode.getSourceBlock()) {\n            const sourceBlock = curNode.getSourceBlock();\n            return sourceBlock && sourceBlock.isDeletable();\n          }\n        }\n        return false;\n      },\n      callback: (workspace, e) => {\n        const sourceBlock = workspace.getCursor().getCurNode().getSourceBlock();\n        // Delete or backspace.\n        // Stop the browser from going back to the previous page.\n        // Do this first to prevent an error in the delete code from resulting\n        // in data loss.\n        e.preventDefault();\n        // Don't delete while dragging.  Jeez.\n        if (Blockly.Gesture.inProgress()) {\n          return false;\n        }\n        this.navigation.moveCursorOnBlockDelete(workspace, sourceBlock);\n        sourceBlock.checkAndDelete();\n        return true;\n      },\n    };\n    Blockly.ShortcutRegistry.registry.register(deleteShortcut);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n        Blockly.utils.KeyCodes.DELETE, deleteShortcut.name, true);\n    Blockly.ShortcutRegistry.registry.addKeyMapping(\n        Blockly.utils.KeyCodes.BACKSPACE, deleteShortcut.name, true);\n  }\n\n  /**\n   * Registers all default keyboard shortcut items for keyboard navigation. This\n   * should be called once per instance of KeyboardShortcutRegistry.\n   * @protected\n   */\n  registerDefaults() {\n    this.registerPrevious();\n    this.registerNext();\n    this.registerIn();\n    this.registerOut();\n\n    this.registerDisconnect();\n    this.registerExit();\n    this.registerInsert();\n    this.registerMark();\n    this.registerToolboxFocus();\n    this.registerToggleKeyboardNav();\n\n    this.registerWorkspaceMoveDown();\n    this.registerWorkspaceMoveLeft();\n    this.registerWorkspaceMoveUp();\n    this.registerWorkspaceMoveRight();\n\n    this.registerCopy();\n    this.registerPaste();\n    this.registerCut();\n    this.registerDelete();\n  }\n\n  /**\n   * Removes all the keyboard navigation shortcuts.\n   * @public\n   */\n  dispose() {\n    const shortcutNames = Object.values(Constants.SHORTCUT_NAMES);\n    for (const name of shortcutNames) {\n      Blockly.ShortcutRegistry.registry.unregister(name);\n    }\n    this.removeShortcutHandlers();\n    this.navigation.dispose();\n  }\n}\n"],"names":["root","factory","exports","module","require","define","amd","a","i","this","__WEBPACK_EXTERNAL_MODULE__573__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","STATE","WORKSPACE","FLYOUT","TOOLBOX","SHORTCUT_NAMES","PREVIOUS","NEXT","IN","OUT","INSERT","MARK","DISCONNECT","EXIT","TOGGLE_KEYBOARD_NAV","COPY","CUT","PASTE","DELETE","MOVE_WS_CURSOR_UP","MOVE_WS_CURSOR_DOWN","MOVE_WS_CURSOR_LEFT","MOVE_WS_CURSOR_RIGHT","LOGGING_MSG_TYPE","ERROR","WARN","LOG","FlyoutCursor","curNode","getCurNode","newNode","next","setCurNode","prev","Blockly","registrationType","registrationName","pluginInfo","LineCursor","getNextNode_","validLineNode","getType","getLocation","targetBlock","validInLineNode","getPreviousNode_","node","isValid","location","type","outputConnection","Navigation","workspaceStates","loggingCallback","WS_MOVE_DISTANCE","MARKER_NAME","DEFAULT_WS_COORDINATE","WS_COORDINATE_ON_DELETE","wsChangeWrapper","workspaceChangeListener","bind","flyoutChangeWrapper","flyoutChangeListener","workspaces","workspace","push","flyout","getFlyout","getMarkerManager","registerMarker","addChangeListener","addFlyout","workspaceIdx","indexOf","getCursor","disableKeyboardAccessibility","splice","unregisterMarker","removeChangeListener","removeFlyout","state","id","getMarker","flyoutWorkspace","getWorkspace","FlyoutCursorClass","cursorRegistrationType","cursorRegistrationName","setCursor","e","workspaceId","keyboardAccessibilityMode","handleBlockDeleteByDrag","element","handleBlockMutation","handleWorkspaceClick","handleToolboxCategoryClick","handleBlockCreate","mainWorkspace","targetWorkspace","autoClose","targetType","block","getBlockById","blockId","handleBlockClickInFlyout","newElementId","getState","Constants","resetFlyout","getToolbox","setState","mutatedBlockId","cursor","getSourceBlock","workspaceState","newItem","focusToolbox","deletedBlockId","ids","sourceBlock","isShadow","getParent","getFlyoutCursor","deletedBlock","topConnection","previousConnection","targetConnection","getRelativeToSurfaceXY","getChildren","toolbox","markAtCursor","getSelectedItem","toolboxItem","toolboxItems","getToolboxItems","isSelectable","selectItemByPosition","topBlocks","getTopBlocks","length","astNode","hideChaff","reset","setCursorOnWorkspaceFocus","wsCoordinates","x","scale","y","wsNode","newBlock","createNewBlock","markerNode","tryToConnectMarkerAndCursor","warn","focusWorkspace","removeMark","isVisible","curBlock","isEnabled","createBlock","render","setConnectionTracking","shouldHide","hide","cursorNode","logConnectionWarning","markerType","cursorType","cursorLoc","markerLoc","isConnection","cursorConnection","markerConnection","connect","cursorBlock","insertBlock","moveBlockToWorkspace","unplug","moveTo","getWsCoordinate","movingConnection","destConnection","inferiorConnection","movingBlock","destBlock","getRootBlock","getDescendants","getInferiorConnection","disconnect","movingInferior","destSuperior","getSuperiorConnection","movingSuperior","destInferior","moveAndConnect","checker","getConnectionChecker","reason","canConnectWithReason","getErrorMessage","connection","isSuperior","canConnect","disconnectChild","positionNearConnection","nextConnection","inputList","inputConnection","curConnection","isConnected","superiorConnection","log","bumpAwayFrom","bringToFront","connectionNode","marker","msg","console","error","xDirection","yDirection","wsCoord","newX","newY","nodeType","showEditor","isHandled","insertPastedBlock","markedNode","removeWorkspace","oldDoWorkspaceClick","ws","creatorWorkspace_","shiftKey","screenCoord","clientX","clientY","oldDoBlockClick","targetBlock_","isInFlyout","mostRecentEvent_","NavigationController","optNavigation","navigation","addShortcutHandlers","registerDefaults","fieldColourHandler","fieldDropdownHandler","toolboxHandler","shortcut","picker_","name","moveHighlightBy_","menu_","highlightPrevious","highlightNext","selectedItem_","selectPrevious_","selectParent_","selectNext_","selectChild_","addWorkspace","enableKeyboardAccessibility","onShortcut","previousShortcut","preconditionFn","callback","fieldShortcutHandler","toggleKeyboardNavShortcut","ctrlShiftK","outShortcut","out","nextShortcut","inShortcut","in","focusFlyout","insertShortcut","options","readOnly","connectMarkerAndCursor","markShortcut","handleEnterForWS","insertFromFlyout","disconnectShortcut","disconnectBlocks","focusToolboxShortcut","exitShortcut","wsMoveLeftShortcut","moveWSCursor","shiftA","wsMoveRightShortcut","shiftD","wsMoveUpShortcut","shiftW","wsMoveDownShortcut","copyShortcut","isDeletable","isMovable","ctrlC","altC","metaC","pasteShortcut","paste","ctrlV","altV","metaV","cutShortcut","isFlyout","moveCursorOnBlockDelete","checkAndDelete","ctrlX","altX","metaX","deleteShortcut","preventDefault","registerPrevious","registerNext","registerIn","registerOut","registerDisconnect","registerExit","registerInsert","registerMark","registerToolboxFocus","registerToggleKeyboardNav","registerWorkspaceMoveDown","registerWorkspaceMoveLeft","registerWorkspaceMoveUp","registerWorkspaceMoveRight","registerCopy","registerPaste","registerCut","registerDelete","values","removeShortcutHandlers","dispose"],"sourceRoot":""}