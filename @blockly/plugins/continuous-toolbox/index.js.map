{"version":3,"file":"index.js","mappings":"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","sources":["webpack://@blockly/continuous-toolbox/webpack/universalModuleDefinition","webpack://@blockly/continuous-toolbox/external umd {\"root\":\"Blockly\",\"commonjs\":\"blockly/core\",\"commonjs2\":\"blockly/core\",\"amd\":\"blockly/core\"}","webpack://@blockly/continuous-toolbox/webpack/bootstrap","webpack://@blockly/continuous-toolbox/webpack/runtime/define property getters","webpack://@blockly/continuous-toolbox/webpack/runtime/hasOwnProperty shorthand","webpack://@blockly/continuous-toolbox/webpack/runtime/make namespace object","webpack://@blockly/continuous-toolbox/./src/ContinuousCategory.js","webpack://@blockly/continuous-toolbox/./src/ContinuousToolbox.js","webpack://@blockly/continuous-toolbox/./src/ContinuousMetricsFlyout.js","webpack://@blockly/continuous-toolbox/./src/ContinuousFlyout.js","webpack://@blockly/continuous-toolbox/./src/ContinuousMetrics.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"blockly/core\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"blockly/core\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"blockly/core\")) : factory(root[\"Blockly\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, (__WEBPACK_EXTERNAL_MODULE__573__) => {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__573__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Toolbox category with styling for continuous toolbox.\n */\n\nimport * as Blockly from 'blockly/core';\n\n/** Toolbox category for continuous toolbox. */\nexport class ContinuousCategory extends Blockly.ToolboxCategory {\n  /**\n   * Constructor for ContinuousCategory which is used in ContinuousToolbox.\n   * @override\n   */\n  constructor(categoryDef, toolbox) {\n    super(categoryDef, toolbox);\n  }\n\n  /** @override */\n  createLabelDom_(name) {\n    const label = document.createElement('div');\n    label.setAttribute('id', this.getId() + '.label');\n    label.textContent = name;\n    label.classList.add(this.cssConfig_['label']);\n    return label;\n  }\n\n  /** @override */\n  createIconDom_() {\n    const icon = document.createElement('div');\n    icon.classList.add('categoryBubble');\n    icon.style.backgroundColor = this.colour_;\n    return icon;\n  }\n\n  /** @override */\n  addColourBorder_() {\n    // No-op\n  }\n\n  /** @override */\n  setSelected(isSelected) {\n    if (isSelected) {\n      this.rowDiv_.style.backgroundColor = 'gray';\n      Blockly.utils.dom.addClass(this.rowDiv_, this.cssConfig_['selected']);\n    } else {\n      this.rowDiv_.style.backgroundColor = '';\n      Blockly.utils.dom.removeClass(this.rowDiv_, this.cssConfig_['selected']);\n    }\n    Blockly.utils.aria.setState(/** @type {!Element} */ (this.htmlDiv_),\n        Blockly.utils.aria.State.SELECTED, isSelected);\n  }\n}\n\nBlockly.registry.register(\n    Blockly.registry.Type.TOOLBOX_ITEM,\n    Blockly.ToolboxCategory.registrationName,\n    ContinuousCategory,\n    true);\n","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Toolbox that uses a continuous scrolling flyout.\n */\n\nimport * as Blockly from 'blockly/core';\nimport {ContinuousFlyout} from './ContinuousFlyout';\n\n/**\n * Class for continuous toolbox.\n */\nexport class ContinuousToolbox extends Blockly.Toolbox {\n  /** @override */\n  constructor(workspace) {\n    super(workspace);\n  }\n\n  /** @override */\n  init() {\n    super.init();\n\n    // Populate the flyout with all blocks and show it immediately.\n    const flyout = this.getFlyout();\n    flyout.show(this.getInitialFlyoutContents_());\n    flyout.recordScrollPositions();\n  }\n\n  /** @override */\n  getFlyout() {\n    return /** @type {ContinuousFlyout} */ (super.getFlyout());\n  }\n\n  /**\n   * Gets the contents that should be shown in the flyout immediately.\n   * This includes all blocks and labels for each category of block.\n   * @return {!Blockly.utils.toolbox.FlyoutItemInfoArray} Flyout contents.\n   * @private\n   */\n  getInitialFlyoutContents_() {\n    /** @type {!Blockly.utils.toolbox.FlyoutItemInfoArray} */\n    let contents = [];\n    for (const toolboxItem of this.contents_) {\n      if (toolboxItem instanceof Blockly.ToolboxCategory) {\n        // Create a label node to go at the top of the category\n        contents.push({kind: 'LABEL', text: toolboxItem.getName()});\n        /**\n         * @type {string|Blockly.utils.toolbox.FlyoutItemInfoArray|\n         *    Blockly.utils.toolbox.FlyoutItemInfo}\n         */\n        let itemContents = toolboxItem.getContents();\n\n        // Handle custom categories (e.g. variables and functions)\n        if (typeof itemContents === 'string') {\n          itemContents =\n            /** @type {!Blockly.utils.toolbox.DynamicCategoryInfo} */ ({\n              custom: itemContents,\n              kind: 'CATEGORY',\n            });\n        }\n        contents = contents.concat(itemContents);\n      }\n    }\n    return contents;\n  }\n\n  /** @override */\n  refreshSelection() {\n    this.getFlyout().show(this.getInitialFlyoutContents_());\n  }\n\n  /** @override */\n  updateFlyout_(_oldItem, newItem) {\n    if (newItem) {\n      const target = this.getFlyout()\n          .getCategoryScrollPosition(newItem.name_).y;\n      this.getFlyout().scrollTo(target);\n    }\n  }\n\n  /** @override */\n  shouldDeselectItem_(oldItem, newItem) {\n    // Should not deselect if the same category is clicked again.\n    return (oldItem && oldItem !== newItem);\n  }\n\n  /**\n   * Gets a category by name.\n   * @param {string} name Name of category to get.\n   * @return {?Blockly.ToolboxCategory} Category, or null if not\n   *    found.\n   * @package\n   */\n  getCategoryByName(name) {\n    const category = this.contents_.find(\n        (item) => item instanceof Blockly.ToolboxCategory &&\n            item.isSelectable() && name === item.getName());\n    if (category) {\n      return /** @type {!Blockly.ToolboxCategory} */ (category);\n    }\n    return null;\n  }\n\n  /**\n   * Selects the category with the given name.\n   * Similar to setSelectedItem, but importantly, does not call updateFlyout\n   * because this is called while the flyout is being scrolled.\n   * @param {string} name Name of category to select.\n   * @package\n   */\n  selectCategoryByName(name) {\n    const newItem = this.getCategoryByName(name);\n    if (!newItem) {\n      return;\n    }\n    const oldItem = this.selectedItem_;\n\n    if (this.shouldDeselectItem_(oldItem, newItem)) {\n      this.deselectItem_(oldItem);\n    }\n\n    if (this.shouldSelectItem_(oldItem, newItem)) {\n      this.selectItem_(oldItem, newItem);\n    }\n  }\n\n  /** @override */\n  getClientRect() {\n    // If the flyout never closes, it should be the deletable area.\n    const flyout = this.getFlyout();\n    if (flyout && !flyout.autoClose) {\n      return flyout.getClientRect();\n    }\n    return super.getClientRect();\n  }\n}\n\n\nBlockly.Css.register([\n  `.categoryBubble {\n      margin: 0 auto 0.125rem;\n      border-radius: 100%;\n      border: 1px solid;\n      width: 1.25rem;\n      height: 1.25rem;\n    }\n    .blocklyTreeRow {\n      height: initial;\n      padding: 3px 0;\n    }\n    .blocklyTreeRowContentContainer {\n      display: flex;\n      flex-direction: column;\n    }\n    .blocklyTreeLabel {\n      margin: auto;\n    }`,\n]);\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n\nimport * as Blockly from 'blockly/core';\n\n/** Adds additional padding to the bottom of the flyout if needed. */\nexport class ContinuousFlyoutMetrics extends Blockly.FlyoutMetricsManager {\n  /** @override */\n  constructor(workspace, flyout) {\n    super(workspace, flyout);\n  }\n  /**\n   * Adds additional padding to the bottom of the flyout if needed,\n   * in order to make it possible to scroll to the top of the last category.\n   * @override\n   */\n  getScrollMetrics(\n      getWorkspaceCoordinates = undefined,\n      cachedViewMetrics = undefined,\n      cachedContentMetrics = undefined) {\n    const scrollMetrics = super.getScrollMetrics(\n        getWorkspaceCoordinates, cachedViewMetrics, cachedContentMetrics);\n    const contentMetrics = cachedContentMetrics ||\n        this.getContentMetrics(getWorkspaceCoordinates);\n    const viewMetrics = cachedViewMetrics ||\n        this.getViewMetrics(getWorkspaceCoordinates);\n\n    if (scrollMetrics) {\n      scrollMetrics.height +=\n          this.flyout_.calculateBottomPadding(contentMetrics, viewMetrics);\n    }\n    return scrollMetrics;\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Flyout that supports always-open continuous scrolling.\n */\n\nimport * as Blockly from 'blockly/core';\nimport {ContinuousToolbox} from './ContinuousToolbox';\nimport {ContinuousFlyoutMetrics} from './ContinuousMetricsFlyout';\n\n/**\n * Class for continuous flyout.\n */\nexport class ContinuousFlyout extends Blockly.VerticalFlyout {\n  /** @override */\n  constructor(workspaceOptions) {\n    super(workspaceOptions);\n\n    /**\n     * List of scroll positions for each category.\n     * @type {!Array<{name: string, position: !Object}>}\n     */\n    this.scrollPositions = [];\n\n    /**\n     * Target scroll position, used to smoothly scroll to a given category\n     * location when selected.\n     * @type {?number}\n     */\n    this.scrollTarget = null;\n\n    /**\n     * The percentage of the distance to the scrollTarget that should be\n     * scrolled at a time. Lower values will produce a smoother, slower scroll.\n     * @type {number}\n     */\n    this.scrollAnimationFraction = 0.3;\n\n    /**\n     * Whether to recycle blocks when refreshing the flyout. When false, do not\n     * allow anything to be recycled. The default is to recycle.\n     * @type {boolean}\n     * @private\n     */\n    this.recyclingEnabled_ = true;\n\n    this.workspace_.setMetricsManager(\n        new ContinuousFlyoutMetrics(this.workspace_, this));\n\n    this.autoClose = false;\n  }\n\n  /**\n   * Gets parent toolbox.\n   * Since we registered the ContinuousToolbox, we know that's its type.\n   * @return {!ContinuousToolbox} Toolbox that owns this flyout.\n   * @private\n   */\n  getParentToolbox_() {\n    const toolbox = this.targetWorkspace.getToolbox();\n    return /** @type {!ContinuousToolbox} */ (toolbox);\n  }\n\n  /**\n   * Records scroll position for each category in the toolbox.\n   * The scroll position is determined by the coordinates of each category's\n   * label after the entire flyout has been rendered.\n   * @package\n   */\n  recordScrollPositions() {\n    this.scrollPositions = [];\n    const categoryLabels = this.buttons_.filter((button) => button.isLabel() &&\n        this.getParentToolbox_().getCategoryByName(button.getButtonText()));\n    for (const button of categoryLabels) {\n      if (button.isLabel()) {\n        this.scrollPositions.push({\n          name: button.getButtonText(),\n          position: button.getPosition(),\n        });\n      }\n    }\n  }\n\n  /**\n   * Returns the scroll position for the given category name.\n   * @param {string} name Category name.\n   * @return {?Object} Scroll position for given category, or null if not found.\n   * @package\n   */\n  getCategoryScrollPosition(name) {\n    for (const scrollInfo of this.scrollPositions) {\n      if (scrollInfo.name === name) {\n        return scrollInfo.position;\n      }\n    }\n    console.warn(`Scroll position not recorded for category ${name}`);\n    return null;\n  }\n\n  /**\n   * Selects an item in the toolbox based on the scroll position of the flyout.\n   * @param {number} position Current scroll position of the workspace.\n   * @private\n   */\n  selectCategoryByScrollPosition_(position) {\n    // If we are currently auto-scrolling, due to selecting a category by\n    // clicking on it, do not update the category selection.\n    if (this.scrollTarget) {\n      return;\n    }\n    const scaledPosition = Math.round(position / this.workspace_.scale);\n    // Traverse the array of scroll positions in reverse, so we can select the\n    // furthest category that the scroll position is beyond.\n    for (let i = this.scrollPositions.length - 1; i >= 0; i--) {\n      const category = this.scrollPositions[i];\n      if (scaledPosition >= category.position.y) {\n        this.getParentToolbox_().selectCategoryByName(category.name);\n        return;\n      }\n    }\n  }\n\n  /**\n   * Scrolls flyout to given position.\n   * @param {number} position The x coordinate to scroll to.\n   */\n  scrollTo(position) {\n    // Set the scroll target to either the scaled position or the lowest\n    // possible scroll point, whichever is smaller.\n    const metrics = this.workspace_.getMetrics();\n    this.scrollTarget = Math.min(position * this.workspace_.scale,\n        metrics.scrollHeight - metrics.viewHeight);\n\n    this.stepScrollAnimation_();\n  }\n\n  /**\n   * Step the scrolling animation by scrolling a fraction of the way to\n   * a scroll target, and request the next frame if necessary.\n   * @private\n   */\n  stepScrollAnimation_() {\n    if (!this.scrollTarget) {\n      return;\n    }\n\n    const currentScrollPos = -this.workspace_.scrollY;\n    const diff = this.scrollTarget - currentScrollPos;\n    if (Math.abs(diff) < 1) {\n      this.workspace_.scrollbar.setY(this.scrollTarget);\n      this.scrollTarget = null;\n      return;\n    }\n    this.workspace_.scrollbar.setY(\n        currentScrollPos + diff * this.scrollAnimationFraction);\n\n    requestAnimationFrame(this.stepScrollAnimation_.bind(this));\n  }\n\n  /**\n   * Add additional padding to the bottom of the flyout if needed,\n   * in order to make it possible to scroll to the top of the last category.\n   * @param {!Blockly.MetricsManager.ContainerRegion} contentMetrics Content\n   *    metrics for the flyout.\n   * @param {!Blockly.MetricsManager.ContainerRegion} viewMetrics View metrics\n   *    for the flyout.\n   * @return {number} Additional bottom padding.\n   */\n  calculateBottomPadding(contentMetrics, viewMetrics) {\n    if (this.scrollPositions.length > 0) {\n      const lastCategory =\n          this.scrollPositions[this.scrollPositions.length - 1];\n      const lastPosition = lastCategory.position.y * this.workspace_.scale;\n      const lastCategoryHeight = contentMetrics.height - lastPosition;\n      if (lastCategoryHeight < viewMetrics.height) {\n        return viewMetrics.height - lastCategoryHeight;\n      }\n    }\n    return 0;\n  }\n\n  /** @override */\n  setMetrics_(xyRatio) {\n    super.setMetrics_(xyRatio);\n    if (this.scrollPositions) {\n      this.selectCategoryByScrollPosition_(-this.workspace_.scrollY);\n    }\n  }\n\n  /**\n   * Overrides the position function solely to change the x coord in RTL mode.\n   * The base function allows the workspace to go \"under\" the flyout, so\n   * to calculate the left edge of the flyout in RTL you would just subtract\n   * the flyout width from the total viewWidth to get x. However, in our\n   * flyout, the workspace already starts at the left edge of the flyout, so\n   * we don't need to subtract the flyout width again.\n   * Ideally there would be a smaller method for us to override instead,\n   * but for now we copy/paste this method and make our fixes.\n   * @override\n   */\n  position() {\n    if (!this.isVisible()) {\n      return;\n    }\n    const targetWorkspaceMetrics = this.targetWorkspace.getMetrics();\n    if (!targetWorkspaceMetrics) {\n      // Hidden components will return null.\n      return;\n    }\n    // Record the height for Blockly.Flyout.getMetrics_\n    this.height_ = targetWorkspaceMetrics.viewHeight;\n\n    const edgeWidth = this.width_ - this.CORNER_RADIUS;\n    const edgeHeight =\n        targetWorkspaceMetrics.viewHeight - 2 * this.CORNER_RADIUS;\n    this.setBackgroundPath_(edgeWidth, edgeHeight);\n\n    // Y is always 0 since this is a vertical flyout.\n    const y = 0;\n    let x = 0;\n    // If this flyout is the toolbox flyout.\n    if (this.targetWorkspace.toolboxPosition == this.toolboxPosition_) {\n      // If there is a category toolbox.\n      if (targetWorkspaceMetrics.toolboxWidth) {\n        if (this.toolboxPosition_ == Blockly.TOOLBOX_AT_LEFT) {\n          x = targetWorkspaceMetrics.toolboxWidth;\n        } else {\n          // TODO(https://github.com/google/blockly/issues/4396): Use a better\n          // API to adjust this value.\n          // This is the only line that changed from the original.\n          x = targetWorkspaceMetrics.viewWidth;\n        }\n      } else {\n        if (this.toolboxPosition_ == Blockly.TOOLBOX_AT_LEFT) {\n          x = 0;\n        } else {\n          x = targetWorkspaceMetrics.viewWidth;\n        }\n      }\n    } else {\n      if (this.toolboxPosition_ == Blockly.TOOLBOX_AT_LEFT) {\n        x = 0;\n      } else {\n        // Because the anchor point of the flyout is on the left, but we want\n        // to align the right edge of the flyout with the right edge of the\n        // blocklyDiv, we calculate the full width of the div minus the width\n        // of the flyout.\n        x = targetWorkspaceMetrics.viewWidth +\n            targetWorkspaceMetrics.absoluteLeft - this.width_;\n      }\n    }\n    this.positionAt_(this.width_, this.height_, x, y);\n  }\n\n  /**\n   * @override\n   */\n  show(flyoutDef) {\n    super.show(flyoutDef);\n    this.recordScrollPositions();\n    this.workspace_.resizeContents();\n  }\n\n  /**\n   * Determine if this block can be recycled in the flyout.  Blocks that have no\n   * variables and are not dynamic shadows can be recycled.\n   * @param {!Blockly.BlockSvg} block The block to attempt to recycle.\n   * @return {boolean} True if the block can be recycled.\n   * @protected\n   */\n  blockIsRecyclable_(block) {\n    if (!this.recyclingEnabled_) {\n      return false;\n    }\n\n    // If the block needs to parse mutations, never recycle.\n    if (block.mutationToDom && block.domToMutation) {\n      return false;\n    }\n\n    for (const input of block.inputList) {\n      for (const field of input.fieldRow) {\n        // No variables.\n        if (field instanceof Blockly.FieldVariable) {\n          return false;\n        }\n        if (field instanceof Blockly.FieldDropdown) {\n          if (field.isOptionListDynamic()) {\n            return false;\n          }\n        }\n      }\n      // Check children.\n      if (input.connection) {\n        const targetBlock = /** @type {Blockly.BlockSvg} */\n            (input.connection.targetBlock());\n        if (targetBlock && !this.blockIsRecyclable_(targetBlock)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Sets the function used to determine whether a block is recyclable.\n   * @param {function(!Blockly.BlockSvg):boolean} func The function used to\n   *     determine if a block is recyclable.\n   * @public\n   */\n  setBlockIsRecyclable(func) {\n    this.blockIsRecyclable_ = func;\n  }\n\n  /**\n   * Set whether the flyout can recycle blocks.\n   * @param {boolean} isEnabled True to allow blocks to be recycled, false\n   *     otherwise.\n   * @public\n   */\n  setRecyclingEnabled(isEnabled) {\n    this.recyclingEnabled_ = isEnabled;\n  }\n}\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Overrides metrics to exclude the flyout from the viewport.\n */\n\nimport * as Blockly from 'blockly/core';\n\n/** Computes metrics for a toolbox with an always open flyout. */\nexport class ContinuousMetrics extends Blockly.MetricsManager {\n  /** @override */\n  constructor(workspace) {\n    super(workspace);\n  }\n  /**\n   * Computes the viewport size to not include the toolbox and the flyout.\n   * The default viewport includes the flyout.\n   * @override\n   */\n  getViewMetrics(getWorkspaceCoordinates = undefined) {\n    const scale = getWorkspaceCoordinates ? this.workspace_.scale : 1;\n    const svgMetrics = this.getSvgMetrics();\n    const toolboxMetrics = this.getToolboxMetrics();\n    const flyoutMetrics = this.getFlyoutMetrics(false);\n    const toolboxPosition = toolboxMetrics.position;\n\n    if (this.workspace_.getToolbox()) {\n      // Note: Not actually supported at this time due to ContinunousToolbox\n      // only supporting a vertical flyout. But included for completeness.\n      if (toolboxPosition == Blockly.TOOLBOX_AT_TOP ||\n          toolboxPosition == Blockly.TOOLBOX_AT_BOTTOM) {\n        svgMetrics.height -= (toolboxMetrics.height + flyoutMetrics.height);\n      } else if (toolboxPosition == Blockly.TOOLBOX_AT_LEFT ||\n          toolboxPosition == Blockly.TOOLBOX_AT_RIGHT) {\n        svgMetrics.width -= (toolboxMetrics.width + flyoutMetrics.width);\n      }\n    }\n    return {\n      height: svgMetrics.height / scale,\n      width: svgMetrics.width / scale,\n      top: -this.workspace_.scrollY / scale,\n      left: -this.workspace_.scrollX / scale,\n    };\n  }\n\n  /**\n   * Moves the absoluteLeft and absoluteTop so they no longer include the\n   * flyout.\n   * @override\n   */\n  getAbsoluteMetrics() {\n    const toolboxMetrics = this.getToolboxMetrics();\n    const flyoutMetrics = this.getFlyoutMetrics(false);\n    const toolboxPosition = toolboxMetrics.position;\n    let absoluteLeft = 0;\n\n    if (this.workspace_.getToolbox() &&\n        toolboxPosition == Blockly.TOOLBOX_AT_LEFT) {\n      absoluteLeft = toolboxMetrics.width + flyoutMetrics.width;\n    }\n    let absoluteTop = 0;\n    if (this.workspace_.getToolbox() &&\n        toolboxPosition == Blockly.TOOLBOX_AT_TOP) {\n      absoluteTop = toolboxMetrics.height + flyoutMetrics.height;\n    }\n    return {\n      top: absoluteTop,\n      left: absoluteLeft,\n    };\n  }\n}\n\nBlockly.registry.register(Blockly.registry.Type.METRICS_MANAGER,\n    'CustomMetricsManager', ContinuousMetrics);\n"],"names":["root","factory","exports","module","require","define","amd","a","i","this","__WEBPACK_EXTERNAL_MODULE__573__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","ContinuousCategory","categoryDef","toolbox","name","label","document","createElement","setAttribute","getId","textContent","classList","add","cssConfig_","icon","style","backgroundColor","colour_","isSelected","rowDiv_","Blockly","htmlDiv_","ContinuousToolbox","workspace","flyout","getFlyout","show","getInitialFlyoutContents_","recordScrollPositions","contents","contents_","toolboxItem","push","kind","text","getName","itemContents","getContents","custom","concat","_oldItem","newItem","target","getCategoryScrollPosition","name_","y","scrollTo","oldItem","find","item","isSelectable","getCategoryByName","selectedItem_","shouldDeselectItem_","deselectItem_","shouldSelectItem_","selectItem_","autoClose","getClientRect","ContinuousFlyoutMetrics","getWorkspaceCoordinates","cachedViewMetrics","cachedContentMetrics","scrollMetrics","contentMetrics","getContentMetrics","viewMetrics","getViewMetrics","height","flyout_","calculateBottomPadding","ContinuousFlyout","workspaceOptions","scrollPositions","scrollTarget","scrollAnimationFraction","recyclingEnabled_","workspace_","setMetricsManager","targetWorkspace","getToolbox","categoryLabels","buttons_","filter","button","isLabel","getParentToolbox_","getButtonText","position","getPosition","scrollInfo","console","warn","scaledPosition","Math","round","scale","length","category","selectCategoryByName","metrics","getMetrics","min","scrollHeight","viewHeight","stepScrollAnimation_","currentScrollPos","scrollY","diff","abs","scrollbar","setY","requestAnimationFrame","bind","lastPosition","lastCategoryHeight","xyRatio","selectCategoryByScrollPosition_","isVisible","targetWorkspaceMetrics","height_","edgeWidth","width_","CORNER_RADIUS","edgeHeight","setBackgroundPath_","x","toolboxPosition","toolboxPosition_","toolboxWidth","viewWidth","absoluteLeft","positionAt_","flyoutDef","resizeContents","block","mutationToDom","domToMutation","inputList","input","fieldRow","field","isOptionListDynamic","connection","targetBlock","blockIsRecyclable_","func","isEnabled","ContinuousMetrics","svgMetrics","getSvgMetrics","toolboxMetrics","getToolboxMetrics","flyoutMetrics","getFlyoutMetrics","width","top","left","scrollX","absoluteTop"],"sourceRoot":""}