{"version":3,"file":"index.js","mappings":"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","sources":["webpack://@blockly/block-plus-minus/webpack/universalModuleDefinition","webpack://@blockly/block-plus-minus/external umd {\"root\":\"Blockly\",\"commonjs\":\"blockly/core\",\"commonjs2\":\"blockly/core\",\"amd\":\"blockly/core\"}","webpack://@blockly/block-plus-minus/webpack/bootstrap","webpack://@blockly/block-plus-minus/webpack/runtime/compat get default export","webpack://@blockly/block-plus-minus/webpack/runtime/define property getters","webpack://@blockly/block-plus-minus/webpack/runtime/hasOwnProperty shorthand","webpack://@blockly/block-plus-minus/webpack/runtime/make namespace object","webpack://@blockly/block-plus-minus/./src/field_minus.js","webpack://@blockly/block-plus-minus/./src/field_plus.js","webpack://@blockly/block-plus-minus/./src/if.js","webpack://@blockly/block-plus-minus/./src/list_create.js","webpack://@blockly/block-plus-minus/./src/procedures.js","webpack://@blockly/block-plus-minus/./src/text_join.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"blockly/core\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"blockly/core\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"blockly/core\")) : factory(root[\"Blockly\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function(__WEBPACK_EXTERNAL_MODULE__573__) {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__573__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview A function that creates a minus button used for mutation.\n */\n'use strict';\n\nimport * as Blockly from 'blockly/core';\n\n/**\n * Creates a minus image field used for mutation.\n * @param {Object=} args Untyped args passed to block.minus when the field\n *     is clicked.\n * @return {Blockly.FieldImage} The minus field.\n */\nexport function createMinusField(args = undefined) {\n  const minus = new Blockly.FieldImage(minusImage, 15, 15, undefined, onClick_);\n  /**\n   * Untyped args passed to block.minus when the field is clicked.\n   * @type {?(Object|undefined)}\n   * @private\n   */\n  minus.args_ = args;\n  return minus;\n}\n\n/**\n * Calls block.minus(args) when the minus field is clicked.\n * @param {Blockly.FieldImage} minusField The field being clicked.\n * @private\n */\nfunction onClick_(minusField) {\n  // TODO: This is a dupe of the mutator code, anyway to unify?\n  const block = minusField.getSourceBlock();\n\n  if (block.isInFlyout) {\n    return;\n  }\n\n  Blockly.Events.setGroup(true);\n\n  const oldMutationDom = block.mutationToDom();\n  const oldMutation = oldMutationDom && Blockly.Xml.domToText(oldMutationDom);\n\n  block.minus(minusField.args_);\n\n  const newMutationDom = block.mutationToDom();\n  const newMutation = newMutationDom && Blockly.Xml.domToText(newMutationDom);\n\n  if (oldMutation != newMutation) {\n    Blockly.Events.fire(new Blockly.Events.BlockChange(\n        block, 'mutation', null, oldMutation, newMutation));\n  }\n  Blockly.Events.setGroup(false);\n}\n\nconst minusImage =\n    'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAw' +\n    'MC9zdmciIHZlcnNpb249IjEuMSIgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0Ij48cGF0aCBkPS' +\n    'JNMTggMTFoLTEyYy0xLjEwNCAwLTIgLjg5Ni0yIDJzLjg5NiAyIDIgMmgxMmMxLjEwNCAw' +\n    'IDItLjg5NiAyLTJzLS44OTYtMi0yLTJ6IiBmaWxsPSJ3aGl0ZSIgLz48L3N2Zz4K';\n","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview A field for a plus button used for mutation.\n */\n'use strict';\n\nimport * as Blockly from 'blockly/core';\n\n/**\n * Creates a plus image field used for mutation.\n * @param {Object=} args Untyped args passed to block.minus when the field\n *     is clicked.\n * @return {Blockly.FieldImage} The Plus field.\n */\nexport function createPlusField(args = undefined) {\n  const plus = new Blockly.FieldImage(plusImage, 15, 15, undefined, onClick_);\n  /**\n   * Untyped args passed to block.plus when the field is clicked.\n   * @type {?(Object|undefined)}\n   * @private\n   */\n  plus.args_ = args;\n  return plus;\n}\n\n/**\n * Calls block.plus(args) when the plus field is clicked.\n * @param {!Blockly.FieldImage} plusField The field being clicked.\n * @private\n */\nfunction onClick_(plusField) {\n  // TODO: This is a dupe of the mutator code, anyway to unify?\n  const block = plusField.getSourceBlock();\n\n  if (block.isInFlyout) {\n    return;\n  }\n\n  Blockly.Events.setGroup(true);\n\n  const oldMutationDom = block.mutationToDom();\n  const oldMutation = oldMutationDom && Blockly.Xml.domToText(oldMutationDom);\n\n  block.plus(plusField.args_);\n\n  const newMutationDom = block.mutationToDom();\n  const newMutation = newMutationDom && Blockly.Xml.domToText(newMutationDom);\n\n  if (oldMutation != newMutation) {\n    Blockly.Events.fire(new Blockly.Events.BlockChange(\n        block, 'mutation', null, oldMutation, newMutation));\n  }\n  Blockly.Events.setGroup(false);\n}\n\nconst plusImage =\n    'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC' +\n    '9zdmciIHZlcnNpb249IjEuMSIgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0Ij48cGF0aCBkPSJNMT' +\n    'ggMTBoLTR2LTRjMC0xLjEwNC0uODk2LTItMi0ycy0yIC44OTYtMiAybC4wNzEgNGgtNC4wNz' +\n    'FjLTEuMTA0IDAtMiAuODk2LTIgMnMuODk2IDIgMiAybDQuMDcxLS4wNzEtLjA3MSA0LjA3MW' +\n    'MwIDEuMTA0Ljg5NiAyIDIgMnMyLS44OTYgMi0ydi00LjA3MWw0IC4wNzFjMS4xMDQgMCAyLS' +\n    '44OTYgMi0ycy0uODk2LTItMi0yeiIgZmlsbD0id2hpdGUiIC8+PC9zdmc+Cg==';\n","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Changes the if block to use a +/- mutator UI.\n */\n\nimport Blockly from 'blockly/core';\nimport {createMinusField} from './field_minus';\nimport {createPlusField} from './field_plus';\n\nconst controlsIfMutator = {\n  /**\n   * Number of else-if inputs on this block.\n   * @type {number}\n   */\n  elseIfCount_: 0,\n  /**\n   * Whether this block has an else input or not.\n   * @type {boolean}\n   */\n  hasElse_: false,\n\n  /**\n   * Creates XML to represent the number of else-if and else inputs.\n   * @return {Element} XML storage element.\n   * @this {Blockly.Block}\n   */\n  mutationToDom: function() {\n    if (!this.elseIfCount_ && !this.hasElse_) {\n      return null;\n    }\n    const container = Blockly.utils.xml.createElement('mutation');\n    container.setAttribute('elseif', this.elseIfCount_);\n    if (this.hasElse_) {\n      // Has to be stored as an int for backwards compat.\n      container.setAttribute('else', 1);\n    }\n    return container;\n  },\n\n  /**\n   * Parses XML to restore the else-if and else inputs.\n   * @param {!Element} xmlElement XML storage element.\n   * @this {Blockly.Block}\n   */\n  domToMutation: function(xmlElement) {\n    const targetCount = parseInt(xmlElement.getAttribute('elseif'), 10) || 0;\n    this.hasElse_ = !!parseInt(xmlElement.getAttribute('else'), 10) || 0;\n    if (this.hasElse_ && !this.getInput('ELSE')) {\n      this.appendStatementInput('ELSE')\n          .appendField(Blockly.Msg['CONTROLS_IF_MSG_ELSE']);\n    }\n    this.updateShape_(targetCount);\n  },\n\n  /**\n   * Returns the state of this block as a JSON serializable object.\n   * @return {{elseIfCount: (number|undefined),\n   *     haseElse: (boolean|undefined)}} The state of this block, ie the else\n   *     if count and else state.\n   */\n  saveExtraState: function() {\n    if (!this.elseIfCount_ && !this.hasElse_) {\n      return null;\n    }\n    const state = Object.create(null);\n    if (this.elseIfCount_) {\n      state['elseIfCount'] = this.elseIfCount_;\n    }\n    if (this.hasElse_) {\n      state['hasElse'] = true;\n    }\n    return state;\n  },\n\n  /**\n   * Applies the given state to this block.\n   * @param {*} state The state to apply to this block, ie the else if count and\n   *     else state.\n   */\n  loadExtraState: function(state) {\n    const targetCount = state['elseIfCount'] || 0;\n    this.hasElse_ = state['hasElse'] || false;\n    if (this.hasElse_ && !this.getInput('ELSE')) {\n      this.appendStatementInput('ELSE')\n          .appendField(Blockly.Msg['CONTROLS_IF_MSG_ELSE']);\n    }\n    this.updateShape_(targetCount);\n  },\n\n  /**\n   * Adds else-if and do inputs to the block until the block matches the\n   * target else-if count.\n   * @param {number} targetCount The target number of else-if inputs.\n   * @this {Blockly.Block}\n   * @private\n   */\n  updateShape_: function(targetCount) {\n    while (this.elseIfCount_ < targetCount) {\n      this.addElseIf_();\n    }\n    while (this.elseIfCount_ > targetCount) {\n      this.removeElseIf_();\n    }\n  },\n\n  /**\n   * Callback for the plus field. Adds an else-if input to the block.\n   */\n  plus: function() {\n    this.addElseIf_();\n  },\n\n  /**\n   * Callback for the minus field. Triggers \"removing\" the input at the specific\n   * index.\n   * @see removeInput_\n   * @param {number} index The index of the else-if input to \"remove\".\n   * @this {Blockly.Block}\n   */\n  minus: function(index) {\n    if (this.elseIfCount_ == 0) {\n      return;\n    }\n    this.removeElseIf_(index);\n  },\n\n  /**\n   * Adds an else-if and a do input to the bottom of the block.\n   * @this {Blockly.Block}\n   * @private\n   */\n  addElseIf_: function() {\n    // Because else-if inputs are 1-indexed we increment first, decrement last.\n    this.elseIfCount_++;\n    this.appendValueInput('IF' + this.elseIfCount_)\n        .setCheck('Boolean')\n        .appendField(Blockly.Msg['CONTROLS_IF_MSG_ELSEIF'])\n        .appendField(\n            createMinusField(this.elseIfCount_), 'MINUS' + this.elseIfCount_);\n    this.appendStatementInput('DO' + this.elseIfCount_)\n        .appendField(Blockly.Msg['CONTROLS_IF_MSG_THEN']);\n\n    // Handle if-elseif-else block.\n    if (this.getInput('ELSE')) {\n      this.moveInputBefore('ELSE', /* put at end */ null);\n    }\n  },\n\n  /**\n   * Appears to remove the input at the given index. Actually shifts attached\n   * blocks and then removes the input at the bottom of the block. This is to\n   * make sure the inputs are always IF0, IF1, etc with no gaps.\n   * @param {?number=} index The index of the input to \"remove\", or undefined\n   *     to remove the last input.\n   * @this {Blockly.Block}\n   * @private\n   */\n  removeElseIf_: function(index = undefined) {\n    // The strategy for removing a part at an index is to:\n    //  - Kick any blocks connected to the relevant inputs.\n    //  - Move all connect blocks from the other inputs up.\n    //  - Remove the last input.\n    // This makes sure all of our indices are correct.\n\n    if (index !== undefined && index!= this.elseIfCount_) {\n      // Each else-if is two inputs on the block:\n      // the else-if input and the do input.\n      const elseIfIndex = index * 2;\n      const inputs = this.inputList;\n      let connection = inputs[elseIfIndex].connection; // If connection.\n      if (connection.isConnected()) {\n        connection.disconnect();\n      }\n      connection = inputs[elseIfIndex + 1].connection; // Do connection.\n      if (connection.isConnected()) {\n        connection.disconnect();\n      }\n      this.bumpNeighbours();\n      for (let i = elseIfIndex + 2, input; (input = this.inputList[i]); i++) {\n        if (input.name == 'ELSE') {\n          break; // Should be last, so break.\n        }\n        const targetConnection = input.connection.targetConnection;\n        if (targetConnection) {\n          this.inputList[i - 2].connection.connect(targetConnection);\n        }\n      }\n    }\n\n    this.removeInput('IF' + this.elseIfCount_);\n    this.removeInput('DO' + this.elseIfCount_);\n    // Because else-if inputs are 1-indexed we increment first, decrement last.\n    this.elseIfCount_--;\n  },\n};\n\n/**\n * Adds the initial plus button to the if block.\n * @this {Blockly.Block}\n */\nconst controlsIfHelper = function() {\n  this.getInput('IF0').insertFieldAt(0, createPlusField(), 'PLUS');\n};\n\nBlockly.Extensions.unregister('controls_if_mutator');\nBlockly.Extensions.registerMutator('controls_if_mutator',\n    controlsIfMutator, controlsIfHelper);\n","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Changes the list_create block to use a +/- mutator UI.\n */\n\nimport Blockly from 'blockly/core';\nimport {createPlusField} from './field_plus';\nimport {createMinusField} from './field_minus';\n\n// Delete original block because there's no way to unregister it:\n// https://github.com/google/blockly-samples/issues/768#issuecomment-885663394\ndelete Blockly.Blocks['lists_create_with'];\n\n/* eslint-disable quotes */\nBlockly.defineBlocksWithJsonArray([\n  {\n    \"type\": \"lists_create_with\",\n    \"message0\": \"%{BKY_LISTS_CREATE_EMPTY_TITLE} %1\",\n    \"args0\": [\n      {\n        \"type\": \"input_dummy\",\n        \"name\": \"EMPTY\",\n      },\n    ],\n    \"output\": \"Array\",\n    \"style\": \"list_blocks\",\n    \"helpUrl\": \"%{BKY_LISTS_CREATE_WITH_HELPURL}\",\n    \"tooltip\": \"%{BKY_LISTS_CREATE_WITH_TOOLTIP}\",\n    \"mutator\": \"new_list_create_with_mutator\",\n  },\n]);\n/* eslint-enable quotes */\n\nconst listCreateMutator = {\n  /**\n   * Number of item inputs the block has.\n   * @type {number}\n   */\n  itemCount_: 0,\n\n  /**\n   * Creates XML to represent number of text inputs.\n   * @return {!Element} XML storage element.\n   * @this {Blockly.Block}\n   */\n  mutationToDom: function() {\n    const container = Blockly.utils.xml.createElement('mutation');\n    container.setAttribute('items', this.itemCount_);\n    return container;\n  },\n  /**\n   * Parses XML to restore the text inputs.\n   * @param {!Element} xmlElement XML storage element.\n   * @this {Blockly.Block}\n   */\n  domToMutation: function(xmlElement) {\n    const targetCount = parseInt(xmlElement.getAttribute('items'), 10);\n    this.updateShape_(targetCount);\n  },\n\n  /**\n   * Returns the state of this block as a JSON serializable object.\n   * @return {{itemCount: number}} The state of this block, ie the item count.\n   */\n  saveExtraState: function() {\n    return {\n      'itemCount': this.itemCount_,\n    };\n  },\n\n  /**\n   * Applies the given state to this block.\n   * @param {*} state The state to apply to this block, ie the item count.\n   */\n  loadExtraState: function(state) {\n    this.updateShape_(state['itemCount']);\n  },\n\n  /**\n   * Adds inputs to the block until it reaches the target number of inputs.\n   * @param {number} targetCount The target number of inputs for the block.\n   * @this {Blockly.Block}\n   * @private\n   */\n  updateShape_: function(targetCount) {\n    while (this.itemCount_ < targetCount) {\n      this.addPart_();\n    }\n    while (this.itemCount_ > targetCount) {\n      this.removePart_();\n    }\n    this.updateMinus_();\n  },\n\n  /**\n   * Callback for the plus image. Adds an input to the end of the block and\n   * updates the state of the minus.\n   */\n  plus: function() {\n    this.addPart_();\n    this.updateMinus_();\n  },\n\n  /**\n   * Callback for the minus image. Removes an input from the end of the block\n   * and updates the state of the minus.\n   */\n  minus: function() {\n    if (this.itemCount_ == 0) {\n      return;\n    }\n    this.removePart_();\n    this.updateMinus_();\n  },\n\n  // To properly keep track of indices we have to increment before/after adding\n  // the inputs, and decrement the opposite.\n  // Because we want our first input to be ADD0 (not ADD1) we increment after.\n\n  /**\n   * Adds an input to the end of the block. If the block currently has no\n   * inputs it updates the top 'EMPTY' input to receive a block.\n   * @this {Blockly.Block}\n   * @private\n   */\n  addPart_: function() {\n    if (this.itemCount_ == 0) {\n      this.removeInput('EMPTY');\n      this.topInput_ = this.appendValueInput('ADD' + this.itemCount_)\n          .appendField(createPlusField(), 'PLUS')\n          .appendField(Blockly.Msg['LISTS_CREATE_WITH_INPUT_WITH']);\n    } else {\n      this.appendValueInput('ADD' + this.itemCount_);\n    }\n    this.itemCount_++;\n  },\n\n  /**\n   * Removes an input from the end of the block. If we are removing the last\n   * input this updates the block to have an 'EMPTY' top input.\n   * @this {Blockly.Block}\n   * @private\n   */\n  removePart_: function() {\n    this.itemCount_--;\n    this.removeInput('ADD' + this.itemCount_);\n    if (this.itemCount_ == 0) {\n      this.topInput_ = this.appendDummyInput('EMPTY')\n          .appendField(createPlusField(), 'PLUS')\n          .appendField(Blockly.Msg['LISTS_CREATE_EMPTY_TITLE']);\n    }\n  },\n\n  /**\n   * Makes it so the minus is visible iff there is an input available to remove.\n   * @private\n   */\n  updateMinus_: function() {\n    const minusField = this.getField('MINUS');\n    if (!minusField && this.itemCount_ > 0) {\n      this.topInput_.insertFieldAt(1, createMinusField(), 'MINUS');\n    } else if (minusField && this.itemCount_ < 1) {\n      this.topInput_.removeField('MINUS');\n    }\n  },\n};\n\n/**\n * Updates the shape of the block to have 3 inputs if no mutation is provided.\n * @this {Blockly.Block}\n */\nconst listCreateHelper = function() {\n  this.getInput('EMPTY').insertFieldAt(0, createPlusField(), 'PLUS');\n  this.updateShape_(3);\n};\n\nBlockly.Extensions.registerMutator('new_list_create_with_mutator',\n    listCreateMutator, listCreateHelper);\n","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Changes the procedure blocks to use a +/- mutator UI.\n */\n\nimport Blockly from 'blockly/core';\nimport {createMinusField} from './field_minus';\nimport {createPlusField} from './field_plus';\n\nBlockly.Msg['PROCEDURE_VARIABLE'] = 'variable:';\n\n// Delete original blocks because there's no way to unregister them:\n// https://github.com/google/blockly-samples/issues/768#issuecomment-885663394\ndelete Blockly.Blocks['procedures_defnoreturn'];\ndelete Blockly.Blocks['procedures_defreturn'];\n\n/* eslint-disable quotes */\nBlockly.defineBlocksWithJsonArray([\n  {\n    \"type\": \"procedures_defnoreturn\",\n    \"message0\": \"%{BKY_PROCEDURES_DEFNORETURN_TITLE} %1 %2\",\n    \"message1\": \"%{BKY_PROCEDURES_DEFNORETURN_DO} %1\",\n    \"args0\": [\n      {\n        \"type\": \"field_input\",\n        \"name\": \"NAME\",\n        \"text\": \"\",\n      },\n      {\n        \"type\": \"input_dummy\",\n        \"name\": \"TOP\",\n      },\n    ],\n    \"args1\": [\n      {\n        \"type\": \"input_statement\",\n        \"name\": \"STACK\",\n      },\n    ],\n    \"style\": \"procedure_blocks\",\n    \"helpUrl\": \"%{BKY_PROCEDURES_DEFNORETURN_HELPURL}\",\n    \"tooltip\": \"%{BKY_PROCEDURES_DEFNORETURN_TOOLTIP}\",\n    \"extensions\": [\n      \"get_procedure_def_no_return\",\n      \"procedure_context_menu\",\n      \"procedure_rename\",\n      \"procedure_vars\",\n    ],\n    \"mutator\": \"procedure_def_mutator\",\n  },\n  {\n    \"type\": \"procedures_defreturn\",\n    \"message0\": \"%{BKY_PROCEDURES_DEFRETURN_TITLE} %1 %2\",\n    \"message1\": \"%{BKY_PROCEDURES_DEFRETURN_DO} %1\",\n    \"message2\": \"%{BKY_PROCEDURES_DEFRETURN_RETURN} %1\",\n    \"args0\": [\n      {\n        \"type\": \"field_input\",\n        \"name\": \"NAME\",\n        \"text\": \"\",\n      },\n      {\n        \"type\": \"input_dummy\",\n        \"name\": \"TOP\",\n      },\n    ],\n    \"args1\": [\n      {\n        \"type\": \"input_statement\",\n        \"name\": \"STACK\",\n      },\n    ],\n    \"args2\": [\n      {\n        \"type\": \"input_value\",\n        \"align\": \"right\",\n        \"name\": \"RETURN\",\n      },\n    ],\n    \"style\": \"procedure_blocks\",\n    \"helpUrl\": \"%{BKY_PROCEDURES_DEFRETURN_HELPURL}\",\n    \"tooltip\": \"%{BKY_PROCEDURES_DEFRETURN_TOOLTIP}\",\n    \"extensions\": [\n      \"get_procedure_def_return\",\n      \"procedure_context_menu\",\n      \"procedure_rename\",\n      \"procedure_vars\",\n    ],\n    \"mutator\": \"procedure_def_mutator\",\n  },\n]);\n/* eslint-enable quotes */\n\n/**\n * Defines the what are essentially info-getters for the procedures_defnoreturn\n * block.\n * @type {{callType_: string, getProcedureDef: (function(): Array)}}\n */\nconst getDefNoReturn = {\n  /**\n   * Returns info about this block to be used by the Blockly.Procedures.\n   * @return {Array} An array of info.\n   * @this {Blockly.Block}\n   */\n  getProcedureDef: function() {\n    const argNames = this.argData_.map((elem) => elem.model.name);\n    return [this.getFieldValue('NAME'), argNames, false];\n  },\n\n  /**\n   * Used by the context menu to create a caller block.\n   * @type {string}\n   */\n  callType_: 'procedures_callnoreturn',\n};\n\nBlockly.Extensions.registerMixin('get_procedure_def_no_return', getDefNoReturn);\n\n/**\n * Defines what are essentially info-getters for the procedures_def_return\n * block.\n * @type {{callType_: string, getProcedureDef: (function(): Array)}}\n */\nconst getDefReturn = {\n  /**\n   * Returns info about this block to be used by the Blockly.Procedures.\n   * @return {Array} An array of info.\n   * @this {Blockly.Block}\n   */\n  getProcedureDef: function() {\n    const argNames = this.argData_.map((elem) => elem.model.name);\n    return [this.getFieldValue('NAME'), argNames, true];\n  },\n  /**\n   * Used by the context menu to create a caller block.\n   * @type {string}\n   */\n  callType_: 'procedures_callreturn',\n};\n\nBlockly.Extensions.registerMixin('get_procedure_def_return', getDefReturn);\n\nconst procedureContextMenu = {\n  /**\n   * Adds an option to create a caller block.\n   * Adds an option to create a variable getter for each variable included in\n   * the procedure definition.\n   * @this {Blockly.Block}\n   * @param {!Array} options The current options for the context menu.\n   */\n  customContextMenu: function(options) {\n    if (this.isInFlyout) {\n      return;\n    }\n\n    // Add option to create caller.\n    const name = this.getFieldValue('NAME');\n    const text = Blockly.Msg['PROCEDURES_CREATE_DO'].replace('%1', name);\n\n    const xml = Blockly.utils.xml.createElement('block');\n    xml.setAttribute('type', this.callType_);\n    xml.appendChild(this.mutationToDom(true));\n    const callback = Blockly.ContextMenu.callbackFactory(this, xml);\n\n    options.push({\n      enabled: true,\n      text: text,\n      callback: callback,\n    });\n\n    if (this.isCollapsed()) {\n      return;\n    }\n\n    // Add options to create getters for each parameter.\n    const varModels = this.getVarModels();\n    for (const model of varModels) {\n      const text = Blockly.Msg['VARIABLES_SET_CREATE_GET']\n          .replace('%1', model.name);\n\n      const xml = Blockly.utils.xml.createElement('block');\n      xml.setAttribute('type', 'variables_get');\n      xml.appendChild(Blockly.Variables.generateVariableFieldDom(model));\n      const callback = Blockly.ContextMenu.callbackFactory(this, xml);\n\n      options.push({\n        enabled: true,\n        text: text,\n        callback: callback,\n      });\n    }\n  },\n};\n\nBlockly.Extensions.registerMixin(\n    'procedure_context_menu', procedureContextMenu);\n\nconst procedureDefMutator = {\n  /**\n   * Create XML to represent the argument inputs.\n   * @param {boolean=} isForCaller If true include the procedure name and\n   *     argument IDs. Used by Blockly.Procedures.mutateCallers for\n   *     reconnection.\n   * @return {!Element} XML storage element.\n   * @this {Blockly.Block}\n   */\n  mutationToDom: function(isForCaller = false) {\n    const container = Blockly.utils.xml.createElement('mutation');\n    if (isForCaller) {\n      container.setAttribute('name', this.getFieldValue('NAME'));\n    }\n    this.argData_.forEach((element) => {\n      const argument = Blockly.utils.xml.createElement('arg');\n      const argModel = element.model;\n      argument.setAttribute('name', argModel.name);\n      argument.setAttribute('varid', argModel.getId());\n      argument.setAttribute('argid', element.argId);\n      if (isForCaller) {\n        argument.setAttribute('paramid', element.argId);\n      }\n      container.appendChild(argument);\n    });\n\n    // Not used by this block, but necessary if switching back and forth\n    // between this mutator UI and the default UI.\n    if (!this.hasStatements_) {\n      container.setAttribute('statements', 'false');\n    }\n\n    return container;\n  },\n\n  /**\n   * Parse XML to restore the argument inputs.\n   * @param {!Element} xmlElement XML storage element.\n   * @this {Blockly.Block}\n   */\n  domToMutation: function(xmlElement) {\n    // We have to handle this so that the user doesn't add blocks to the stack,\n    // in which case it would be impossible to return to the old mutators.\n    this.hasStatements_ = xmlElement.getAttribute('statements') !== 'false';\n    if (!this.hasStatements_) {\n      this.removeInput('STACK');\n    }\n\n    const names = [];\n    const varIds = [];\n    const argIds = [];\n    for (const childNode of xmlElement.childNodes) {\n      if (childNode.nodeName.toLowerCase() == 'arg') {\n        names.push(childNode.getAttribute('name'));\n        varIds.push(childNode.getAttribute('varid') ||\n            childNode.getAttribute('varId'));\n        argIds.push(childNode.getAttribute('argid'));\n      }\n    }\n    this.updateShape_(names, varIds, argIds);\n  },\n\n  /**\n   * Returns the state of this block as a JSON serializable object.\n   * @return {{params: (!Array<{name: string, id: string}>|undefined),\n   *     hasStatements: (boolean|undefined)}} The state of this block, eg the\n   *     parameters and statements.\n   */\n  saveExtraState: function() {\n    if (!this.argData_.length && this.hasStatements_) {\n      return null;\n    }\n\n    const state = Object.create(null);\n    if (this.argData_.length) {\n      state['params'] = [];\n      this.argData_.forEach((arg) => {\n        const model = arg.model;\n        state['params'].push({\n          'name': model.name,\n          'id': model.getId(),\n          'argId': arg.argId,\n        });\n      });\n    }\n    if (!this.hasStatements_) {\n      state['hasStatements'] = false;\n    }\n    return state;\n  },\n\n  /**\n   * Applies the given state to this block.\n   * @param {*} state The state to apply to this block, eg the parameters and\n   *     statements.\n   */\n  loadExtraState: function(state) {\n    // We have to handle this so that the user doesn't add blocks to the stack,\n    // in which case it would be impossible to return to the old mutators.\n    this.hasStatements_ = state['hasStatements'] !== false;\n    if (!this.hasStatements_) {\n      this.removeInput('STACK');\n    }\n\n    const names = [];\n    const varIds = [];\n    const argIds = [];\n    if (state['params']) {\n      for (let i = 0; i < state['params'].length; i++) {\n        const param = state['params'][i];\n        names.push(param['name']);\n        varIds.push(param['id']);\n        argIds.push(param['argId']);\n      }\n    }\n    this.updateShape_(names, varIds, argIds);\n  },\n\n  /**\n   * Adds arguments to the block until it matches the targets.\n   * @param {!Array<string>} names An array of argument names to display.\n   * @param {!Array<string>} varIds An array of variable IDs associated with\n   *     those names.\n   * @param {!Array<?string>} argIds An array of argument IDs associated with\n   *     those names.\n   * @this {Blockly.Block}\n   * @private\n   */\n  updateShape_: function(names, varIds, argIds) {\n    if (names.length != varIds.length) {\n      throw Error('names and varIds must have the same length.');\n    }\n    // Usually it's more efficient to modify the block, rather than tearing it\n    // down and rebuilding (less render calls), but in this case it's easier\n    // to just work from scratch.\n\n    // We need to remove args in reverse order so that it doesn't mess up\n    // as removeArg_ modifies our array.\n    for (let i = this.argData_.length - 1; i >= 0; i--) {\n      this.removeArg_(this.argData_[i].argId);\n    }\n    this.argData_ = [];\n    const length = varIds.length;\n    for (let i = 0; i < length; i++) {\n      this.addArg_(names[i], varIds[i], argIds[i]);\n    }\n    Blockly.Procedures.mutateCallers(this);\n  },\n\n  /**\n   * Callback for the plus image. Adds an argument to the block and mutates\n   * callers to match.\n   */\n  plus: function() {\n    this.addArg_();\n    Blockly.Procedures.mutateCallers(this);\n  },\n\n  /**\n   * Callback for the minus image. Removes the argument associated with the\n   * given argument ID and mutates the callers to match.\n   * @param {string} argId The argId of the argument to remove.\n   * @this {Blockly.Block}\n   */\n  minus: function(argId) {\n    if (!this.argData_.length) {\n      return;\n    }\n    this.removeArg_(argId);\n    Blockly.Procedures.mutateCallers(this);\n  },\n\n  /**\n   * Adds an argument to the block and updates the block's parallel tracking\n   * arrays as appropriate.\n   * @param {?string=} name An optional name for the argument.\n   * @param {?string=} varId An optional variable ID for the argument.\n   * @param {?string=} argId An optional argument ID for the argument\n   *     (used to identify the argument across variable merges).\n   * @this {Blockly.Block}\n   * @private\n   */\n  addArg_: function(name = null, varId = null, argId = null) {\n    if (!this.argData_.length) {\n      const withField = new Blockly.FieldLabel(\n          Blockly.Msg['PROCEDURES_BEFORE_PARAMS']);\n      this.getInput('TOP')\n          .appendField(withField, 'WITH');\n    }\n\n    const argNames = this.argData_.map((elem) => elem.model.name);\n    name = name || Blockly.Variables.generateUniqueNameFromOptions(\n        Blockly.Procedures.DEFAULT_ARG, argNames);\n    const variable = Blockly.Variables.getOrCreateVariablePackage(\n        this.workspace, varId, name, '');\n    argId = argId || Blockly.utils.idGenerator.genUid();\n\n    this.addVarInput_(name, argId);\n    if (this.getInput('STACK')) {\n      this.moveInputBefore(argId, 'STACK');\n    } else {\n      this.moveInputBefore(argId, 'RETURN');\n    }\n\n    this.argData_.push({\n      model: variable,\n      argId: argId,\n    });\n  },\n\n  /**\n   * Removes the argument associated with the given argument ID from the block.\n   * @param {string} argId An ID used to track arguments on the block.\n   * @private\n   */\n  removeArg_: function(argId) {\n    if (this.removeInput(argId, true)) {\n      if (this.argData_.length == 1) { // Becoming argumentless.\n        this.getInput('TOP').removeField('WITH');\n      }\n      this.argData_ = this.argData_.filter((element) => element.argId != argId);\n    }\n  },\n\n  /**\n   * Appends the actual inputs and fields associated with an argument to the\n   * block.\n   * @param {string} name The name of the argument.\n   * @param {string} argId The UUID of the argument (different from var ID).\n   * @this {Blockly.Block}\n   * @private\n   */\n  addVarInput_: function(name, argId) {\n    const nameField = new Blockly.FieldTextInput(name, this.validator_);\n    nameField.onFinishEditing_ = this.finishEditing_.bind(nameField);\n    nameField.varIdsToDelete_ = [];\n    nameField.preEditVarModel_ = null;\n\n    this.appendDummyInput(argId)\n        .setAlign(Blockly.ALIGN_RIGHT)\n        .appendField(createMinusField(argId))\n        .appendField(Blockly.Msg['PROCEDURE_VARIABLE']) // Untranslated!\n        .appendField(nameField, argId); // The name of the field is the arg id.\n  },\n\n  /**\n   * Validates text entered into the argument name field.\n   * @param {string} newName The new text entered into the field.\n   * @return {?string} The field's new value.\n   * @this {Blockly.FieldTextInput}\n   */\n  validator_: function(newName) {\n    const sourceBlock = this.getSourceBlock();\n    const workspace = sourceBlock.workspace;\n    const argData = sourceBlock.argData_;\n    const argDatum = sourceBlock.argData_.find(\n        (element) => element.argId == this.name);\n    const currId = argDatum.model.getId();\n\n    // Replace all whitespace with normal spaces, then trim.\n    newName = newName.replace(/[\\s\\xa0]+/g, ' ').trim();\n    const caselessName = newName.toLowerCase();\n\n    /**\n     * Returns true if the given argDatum is associated with this field, or has\n     * a different caseless name than the argDatum associated with this field.\n     * @param {{model: Blockly.VariableModel, argId:string}} argDatum The\n     *     argDatum we want to make sure does not conflict with the argDatum\n     *     associated with this field.\n     * @return {boolean} True if the given datum does not conflict with the\n     *     datum associated with this field.\n     * @this {Blockly.FieldTextInput}\n     */\n    const hasDifName = (argDatum) => {\n      // The field name (aka id) is always equal to the arg id.\n      return argDatum.argId == this.name ||\n          caselessName != argDatum.model.name.toLowerCase();\n    };\n    /**\n     * Returns true if the variable associated with this field is only used\n     * by this block, or callers of this procedure.\n     * @return {boolean} True if the variable associated with this field is only\n     *     used by this block, or callers of this procedure.\n     */\n    const varOnlyUsedHere = () => {\n      return workspace.getVariableUsesById(currId).every((block) => {\n        return block.id == sourceBlock.id ||\n            (block.getProcedureCall &&\n                block.getProcedureCall() == sourceBlock.getProcedureDef()[0]);\n      });\n    };\n\n    if (!newName || !argData.every(hasDifName)) {\n      if (this.preEditVarModel_) {\n        argDatum.model = this.preEditVarModel_;\n        this.preEditVarModel_ = null;\n      }\n      Blockly.Procedures.mutateCallers(sourceBlock);\n      return null;\n    }\n\n    if (!this.varIdsToDelete_.length) {\n      this.preEditVarModel_ = argDatum.model;\n      if (varOnlyUsedHere()) {\n        this.varIdsToDelete_.push(currId);\n      }\n    }\n\n    // Create new vars instead of renaming the old ones, so users can't\n    // accidentally rename/coalesce vars.\n    let model = workspace.getVariable(newName, '');\n    if (!model) {\n      model = workspace.createVariable(newName, '');\n      this.varIdsToDelete_.push(model.getId());\n    } else if (model.name != newName) {\n      // Blockly is case-insensitive so we have to update the var instead of\n      // creating a new one.\n      workspace.renameVariableById(model.getId(), newName);\n    }\n    if (model.getId() != currId) {\n      argDatum.model = model;\n    }\n    Blockly.Procedures.mutateCallers(sourceBlock);\n    return newName;\n  },\n\n  /**\n   * Removes any unused vars that were created as a result of editing.\n   * @param {string} _finalName The final value of the field.\n   * @this {Blockly.FieldTextInput}\n   */\n  finishEditing_: function(_finalName) {\n    const source = this.getSourceBlock();\n    const argDatum = source.argData_.find(\n        (element) => element.argId == this.name);\n\n    const currentVarId = argDatum.model.getId();\n    this.varIdsToDelete_.forEach((id) => {\n      if (id != currentVarId) {\n        source.workspace.deleteVariableById(id);\n      }\n    });\n    this.varIdsToDelete_.length = 0;\n    this.preEditVarModel_ = null;\n  },\n};\n\n/**\n * Initializes some private variables for procedure blocks.\n * @this {Blockly.Block}\n */\nconst procedureDefHelper = function() {\n  /**\n   * An array of objects containing data about the args belonging to the\n   * procedure definition.\n   * @type {!Array<{\n   *          model:Blockly.VariableModel,\n   *          argId: string\n   *       }>}\n   * @private\n   */\n  this.argData_ = [];\n  /**\n   * Does this block have a 'STACK' input for statements?\n   * @type {boolean}\n   * @private\n   */\n  this.hasStatements_ = true;\n\n  this.getInput('TOP').insertFieldAt(0, createPlusField(), 'PLUS');\n};\n\nBlockly.Extensions.registerMutator('procedure_def_mutator',\n    procedureDefMutator, procedureDefHelper);\n\n/**\n * Sets the validator for the procedure's name field.\n * @this {Blockly.Block}\n */\nconst procedureRename = function() {\n  this.getField('NAME').setValidator(Blockly.Procedures.rename);\n};\n\nBlockly.Extensions.register('procedure_rename', procedureRename);\n\n/**\n * Defines functions for dealing with variables and renaming variables.\n * @this {Blockly.Block}\n */\nconst procedureVars = function() {\n  // This is a hack to get around the don't-override-builtins check.\n  const mixin = {\n    /**\n     * Return all variables referenced by this block.\n     * @return {!Array.<string>} List of variable names.\n     * @this {Blockly.Block}\n     */\n    getVars: function() {\n      return this.argData_.map((elem) => elem.model.name);\n    },\n\n    /**\n     * Return all variables referenced by this block.\n     * @return {!Array.<!Blockly.VariableModel>} List of variable models.\n     * @this {Blockly.Block}\n     */\n    getVarModels: function() {\n      return this.argData_.map((elem) => elem.model);\n    },\n\n    /**\n     * Notification that a variable was renamed to the same name as an existing\n     * variable. These variables are coalescing into a single variable with the\n     * ID of the variable that was already using the name.\n     * @param {string} oldId The ID of the variable that was renamed.\n     * @param {string} newId The ID of the variable that was already using\n     *     the name.\n     */\n    renameVarById: function(oldId, newId) {\n      const argData = this.argData_.find(\n          (element) => element.model.getId() == oldId);\n      if (!argData) {\n        return; // Not on this block.\n      }\n\n      const newVar = this.workspace.getVariableById(newId);\n      const newName = newVar.name;\n      this.addVarInput_(newName, newId);\n      this.moveInputBefore(newId, oldId);\n      this.removeInput(oldId);\n      argData.model = newVar;\n      Blockly.Procedures.mutateCallers(this);\n    },\n\n    /**\n     * Notification that a variable is renaming but keeping the same ID.  If the\n     * variable is in use on this block, rerender to show the new name.\n     * @param {!Blockly.VariableModel} variable The variable being renamed.\n     * @package\n     * @override\n     * @this {Blockly.Block}\n     */\n    updateVarName: function(variable) {\n      const id = variable.getId();\n      const argData = this.argData_.find(\n          (element) => element.model.getId() == id);\n      if (!argData) {\n        return; // Not on this block.\n      }\n      this.setFieldValue(variable.name, argData.argId);\n      argData.model = variable;\n    },\n  };\n\n  this.mixin(mixin, true);\n};\n\nBlockly.Extensions.register('procedure_vars', procedureVars);\n","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Changes the text_join block to use a +/- mutator UI.\n */\n\nimport Blockly from 'blockly/core';\nimport {createPlusField} from './field_plus';\nimport {createMinusField} from './field_minus';\n\nconst textJoinMutator = {\n  /**\n   * Number of text inputs on this block.\n   * @type {number}\n   */\n  itemCount_: 0,\n\n  /**\n   * Creates XML to represent number of inputs.\n   * @return {!Element} XML storage element.\n   * @this {Blockly.Block}\n   */\n  mutationToDom: function() {\n    const container = Blockly.utils.xml.createElement('mutation');\n    container.setAttribute('items', this.itemCount_);\n    return container;\n  },\n\n  /**\n   * Parses XML to restore the inputs.\n   * @param {!Element} xmlElement XML storage element.\n   * @this {Blockly.Block}\n   */\n  domToMutation: function(xmlElement) {\n    const targetCount = parseInt(xmlElement.getAttribute('items'), 10);\n    this.updateShape_(targetCount);\n  },\n\n  /**\n   * Returns the state of this block as a JSON serializable object.\n   * @return {{itemCount: number}} The state of this block, ie the item count.\n   */\n  saveExtraState: function() {\n    return {\n      'itemCount': this.itemCount_,\n    };\n  },\n\n  /**\n   * Applies the given state to this block.\n   * @param {*} state The state to apply to this block, ie the item count.\n   */\n  loadExtraState: function(state) {\n    this.updateShape_(state['itemCount']);\n  },\n\n  /**\n   * Adds inputs to the block until the block reaches the target input count.\n   * @param {number} targetCount The number of inputs the block should have.\n   * @this {Blockly.Block}\n   * @private\n   */\n  updateShape_: function(targetCount) {\n    while (this.itemCount_ < targetCount) {\n      this.addPart_();\n    }\n    while (this.itemCount_ > targetCount) {\n      this.removePart_();\n    }\n    this.updateMinus_();\n  },\n\n  /**\n   * Callback for the plus image. Adds an input to the block and updates the\n   * state of the minus.\n   * @this {Blockly.Block}\n   */\n  plus: function() {\n    this.addPart_();\n    this.updateMinus_();\n  },\n\n  /**\n   * Callback for the minus image. Removes the input at the end of the block and\n   * updates the state of the minus.\n   * @this {Blockly.Block}\n   */\n  minus: function() {\n    if (this.itemCount_ == 0) {\n      return;\n    }\n    this.removePart_();\n    this.updateMinus_();\n  },\n\n  /**\n   * Adds an input to the end of the block. If the block currently has no\n   * inputs it updates the top 'EMPTY' input to receive a block.\n   * @this {Blockly.Block}\n   * @private\n   */\n  addPart_: function() {\n    if (this.itemCount_ == 0) {\n      if (this.getInput('EMPTY')) {\n        this.removeInput('EMPTY');\n      }\n      this.topInput_ = this.appendValueInput('ADD' + this.itemCount_)\n          .appendField(createPlusField(), 'PLUS')\n          .appendField(Blockly.Msg['TEXT_JOIN_TITLE_CREATEWITH']);\n    } else {\n      this.appendValueInput('ADD' + this.itemCount_);\n    }\n    // Because item inputs are 0-index we decrement first, increment last.\n    this.itemCount_++;\n  },\n\n  /**\n   * Removes an input from the end of the block. If we are removing the last\n   * input this updates the block to have an 'EMPTY' top input.\n   * @this {Blockly.Block}\n   * @private\n   */\n  removePart_: function() {\n    this.itemCount_--;\n    this.removeInput('ADD' + this.itemCount_);\n    if (this.itemCount_ == 0) {\n      this.topInput_ = this.appendDummyInput('EMPTY')\n          .appendField(createPlusField(), 'PLUS')\n          .appendField(this.newQuote_(true))\n          .appendField(this.newQuote_(false));\n    }\n  },\n\n  /**\n   * Makes it so the minus is visible iff there is an input available to remove.\n   * @private\n   */\n  updateMinus_: function() {\n    const minusField = this.getField('MINUS');\n    if (!minusField && this.itemCount_ > 0) {\n      this.topInput_.insertFieldAt(1, createMinusField(), 'MINUS');\n    } else if (minusField && this.itemCount_ < 1) {\n      this.topInput_.removeField('MINUS');\n    }\n  },\n};\n\n/**\n * Adds the quotes mixin to the block. Also updates the shape so that if no\n * mutator is provided the block has two inputs.\n * @this {Blockly.Block}\n */\nconst textJoinHelper = function() {\n  Blockly.Extensions.apply('text_quotes', this, false);\n  this.updateShape_(2);\n};\n\nBlockly.Extensions.unregister('text_join_mutator');\nBlockly.Extensions.registerMutator('text_join_mutator',\n    textJoinMutator, textJoinHelper);\n"],"names":["root","factory","exports","module","require","define","amd","a","i","this","__WEBPACK_EXTERNAL_MODULE__573__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","n","getter","__esModule","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","createMinusField","args","minus","Blockly","minusImage","onClick_","args_","minusField","block","getSourceBlock","isInFlyout","oldMutationDom","mutationToDom","oldMutation","newMutationDom","newMutation","createPlusField","plus","plusImage","plusField","controlsIfMutator","elseIfCount_","hasElse_","container","setAttribute","domToMutation","xmlElement","targetCount","parseInt","getAttribute","getInput","appendStatementInput","appendField","updateShape_","saveExtraState","state","create","loadExtraState","addElseIf_","removeElseIf_","index","appendValueInput","setCheck","moveInputBefore","elseIfIndex","inputs","inputList","connection","isConnected","disconnect","bumpNeighbours","input","name","targetConnection","connect","removeInput","insertFieldAt","listCreateMutator","itemCount_","addPart_","removePart_","updateMinus_","topInput_","appendDummyInput","getField","removeField","getProcedureDef","argNames","argData_","map","elem","model","getFieldValue","callType_","procedureContextMenu","customContextMenu","options","text","xml","appendChild","callback","push","enabled","isCollapsed","getVarModels","procedureDefMutator","isForCaller","forEach","element","argument","argModel","getId","argId","hasStatements_","names","varIds","argIds","childNodes","childNode","nodeName","toLowerCase","length","arg","param","Error","removeArg_","addArg_","varId","withField","variable","workspace","addVarInput_","filter","nameField","validator_","onFinishEditing_","finishEditing_","bind","varIdsToDelete_","preEditVarModel_","setAlign","newName","sourceBlock","argData","argDatum","find","currId","caselessName","replace","trim","every","getVariableUsesById","id","getProcedureCall","getVariable","renameVariableById","createVariable","_finalName","source","currentVarId","deleteVariableById","setValidator","mixin","getVars","renameVarById","oldId","newId","newVar","getVariableById","updateVarName","setFieldValue","textJoinMutator","newQuote_"],"sourceRoot":""}