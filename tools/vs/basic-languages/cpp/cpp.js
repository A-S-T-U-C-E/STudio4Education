/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define('vs/basic-languages/cpp/cpp',["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.language = exports.conf = void 0;
    exports.conf = {
        comments: {
            lineComment: '//',
            blockComment: ['/*', '*/']
        },
        brackets: [
            ['{', '}'],
            ['[', ']'],
            ['(', ')']
        ],
        autoClosingPairs: [
            { open: '[', close: ']' },
            { open: '{', close: '}' },
            { open: '(', close: ')' },
            { open: "'", close: "'", notIn: ['string', 'comment'] },
            { open: '"', close: '"', notIn: ['string'] }
        ],
        surroundingPairs: [
            { open: '{', close: '}' },
            { open: '[', close: ']' },
            { open: '(', close: ')' },
            { open: '"', close: '"' },
            { open: "'", close: "'" }
        ],
        folding: {
            markers: {
                start: new RegExp('^\\s*#pragma\\s+region\\b'),
                end: new RegExp('^\\s*#pragma\\s+endregion\\b')
            }
        }
    };
    exports.language = {
        defaultToken: '',
        tokenPostfix: '.cpp',
        brackets: [
            { token: 'delimiter.curly', open: '{', close: '}' },
            { token: 'delimiter.parenthesis', open: '(', close: ')' },
            { token: 'delimiter.square', open: '[', close: ']' },
            { token: 'delimiter.angle', open: '<', close: '>' }
        ],
        keywords: [
					'abs',
					'abstract',
					'accept',
					'acos',
					'acosf',
					'amp',
					'ANALOG_MESSAGE',
					'analogRead',
					'analogReadResolution',
					'analogReference',
					'analogWrite',
					'analogWriteResolution',
					'and',
					'array',
					'asin',
					'asinf',
					'atan',
					'atan2',
					'atan2f',
					'atanf',
					'atomic_bool',
					'atomic_char',
					'atomic_int',
					'atomic_llong',
					'atomic_long',
					'atomic_schar',
					'atomic_short',
					'atomic_uchar',
					'atomic_uint',
					'atomic_ullong',
					'atomic_ulong',
					'atomic_ushort',
					'attachInterrupt',
					'auto',
					'available',
					'availableForWrite',
					'begin',
					'BIN',
					'bit',
					'bitClear',
					'bitRead',
					'bitSet',
					'bitWrite',
					'bool',
					'boolean',
					'break',
					'byte',
					'case',
					'catch',
					'cbrt',
					'cbrtf',
					'ceil',
					'ceilf',
					'CHANGE',
					'char',
					'char16_t',
					'char32_t',
					'charAt',
					'class',
					'click',
					'compareTo',
					'complex',
					'concat',
					'const',
					'const_cast',
					'constexpr',
					'constrain',
					'continue',
					'copysign',
					'copysignf',
					'cos',
					'cosf',
					'cosh',
					'coshf',
					'cpu',
					'DEC',
					'decltype',
					'DEFAULT',
					'default',
					'degrees',
					'delay',
					'delayMicroseconds',
					'delegate',
					'delete',
					'detachInterrupt',
					'DIGITAL_MESSAGE',
					'digitalPinToInterrupt',
					'digitalRead',
					'digitalWrite',
					'do',
					'double',
					'dynamic_cast',
					'each',
					'else',
					'end',
					'endsWith',
					'enum',
					'equals',
					'equalsIgnoreCase',
					'event',
					'exp',
					'expf',
					'explicit',
					'export',
					'extern',
					'EXTERNAL',
					'fabs',
					'fabsf',
					'FALLING',
					'fdim',
					'fdimf',
					'final',
					'finally',
					'find',
					'findUntil',
					'FIRMATA_STRING',
					'float',
					'floor',
					'floorf',
					'flush',
					'fma',
					'fmaf',
					'fmax',
					'fmaxf',
					'fmin',
					'fminf',
					'fmod',
					'fmodf',
					'for',
					'friend',
					'gcnew',
					'generic',
					'getBytes',
					'goto',
					'HALF_PI',
					'HEX',
					'HIGH',
					'highByte',
					'hypot',
					'hypotf',
					'if',
					'in',
					'indexOf',
					'initonly',
					'inline',
					'INPUT',
					'INPUT_PULLUP',
					'int',
					'int16_t',
					'int32_t',
					'int64_t',
					'int8_t',
					'interface',
					'interior_ptr',
					'INTERNAL',
					'internal',
					'INTERNAL1V1',
					'INTERNAL2V56',
					'interrupts',
					'isAlpha',
					'isAlphaNumeric',
					'isAscii',
					'isControl',
					'isDigit',
					'isfinite',
					'isGraph',
					'isHexadecimalDigit',
					'isinf',
					'isLowerCase',
					'isnan',
					'isPressed',
					'isPrintable',
					'isPunct',
					'isSpace',
					'isUpperCase',
					'isWhitespace',
					'Keyboard',
					'lastIndexOf',
					'ldexp',
					'ldexpf',
					'LED_BUILTIN',
					'LED_BUILTIN_RX',
					'LED_BUILTIN_TX',
					'length',
					'literal',
					'log',
					'log10',
					'log10f',
					'logf',
					'long',
					'LOW',
					'lowByte',
					'lrint',
					'lrintf',
					'lround',
					'lroundf',
					'LSBFIRST',
					'map',
					'max',
					'micros',
					'millis',
					'min',
					'Mouse',
					'move',
					'MSBFIRST',
					'mutable',
					'namespace',
					'new',
					'noexcept',
					'noInterrupts',
					'not',
					'noTone',
					'null',
					'NULL',
					'nullptr',
					'OCT',
					'operator',
					'or',
					'OUTPUT',
					'override',
					'parseFloat',
					'parseInt',
					'partial',
					'pascal',
					'peek',
					'PI',
					'pin_ptr',
					'pinMode',
					'pow',
					'powf',
					'press',
					'print',
					'println',
					'private',
					'PROGMEM',
					'property',
					'protected',
					'public',
					'pulseIn',
					'pulseInLong',
					'radians',
					'random',
					'randomSeed',
					'read',
					'readBytes',
					'readBytesUntil',
					'readString',
					'readStringUntil',
					'ref',
					'register',
					'reinterpret_cast',
					'release',
					'releaseAll',
					'replace',
					'REPORT_ANALOG',
					'REPORT_DIGITAL',
					'restrict',
					'return',
					'RISING',
					'round',
					'roundf',
					'safe_cast',
					'sealed',
					'Serial',
					'Serial1',
					'Serial2',
					'Serial3',
					'SerialUSB',
					'SET_PIN_MODE',
					'setCharAt',
					'setTimeout',
					'shiftIn',
					'shiftOut',
					'short',
					'signbit',
					'signed',
					'sin',
					'sinf',
					'sinh',
					'sinhf',
					'sizeof',
					'sq',
					'sqrt',
					'sqrtf',
					'startsWith',
					'static',
					'static_assert',
					'static_cast',
					'Stream',
					'String',
					'struct',
					'substring',
					'switch',
					'SYSEX_START',
					'SYSTEM_RESET',
					'tan',
					'tanf',
					'tanh',
					'tanhf',
					'template',
					'this',
					'thread_local',
					'throw',
					'tile_static',
					'toCharArray',
					'toInt',
					'toLowerCase',
					'tone',
					'toUpperCase',
					'trim',
					'trunc',
					'truncf',
					'try',
					'TWO_PI',
					'typedef',
					'typeid',
					'typename',
					'uint16_t',
					'uint32_t',
					'uint64_t',
					'uint8_t',
					'union',
					'unsigned',
					'using',
					'virtual',
					'void',
					'volatile',
					'wchar_t',
					'where',
					'while',
					'word',
					'xor',
					'yield',
					'FALSE',
					'TRUE'
        ],
        operators: [
            '=',
            '>',
            '<',
            '!',
            '~',
            '?',
            ':',
            '==',
            '<=',
            '>=',
            '!=',
            '&&',
            '||',
            '++',
            '--',
            '+',
            '-',
            '*',
            '/',
            '&',
            '|',
            '^',
            '%',
            '<<',
            '>>',
            '>>>',
            '+=',
            '-=',
            '*=',
            '/=',
            '&=',
            '|=',
            '^=',
            '%=',
            '<<=',
            '>>=',
            '>>>='
        ],
        // we include these common regular expressions
        symbols: /[=><!~?:&|+\-*\/\^%]+/,
        escapes: /\\(?:[abfnrtv\\"']|x[0-9A-Fa-f]{1,4}|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})/,
        integersuffix: /([uU](ll|LL|l|L)|(ll|LL|l|L)?[uU]?)/,
        floatsuffix: /[fFlL]?/,
        encoding: /u|u8|U|L/,
        // The main tokenizer for our languages
        tokenizer: {
            root: [
                // C++ 11 Raw String
                [/@encoding?R\"(?:([^ ()\\\t]*))\(/, { token: 'string.raw.begin', next: '@raw.$1' }],
                // identifiers and keywords
                [
                    /[a-zA-Z_]\w*/,
                    {
                        cases: {
                            '@keywords': { token: 'keyword.$0' },
                            '@default': 'identifier'
                        }
                    }
                ],
                // The preprocessor checks must be before whitespace as they check /^\s*#/ which
                // otherwise fails to match later after other whitespace has been removed.
                // Inclusion
                [/^\s*#\s*include/, { token: 'keyword.directive.include', next: '@include' }],
                // Preprocessor directive
                [/^\s*#\s*\w+/, 'keyword.directive'],
                // whitespace
                { include: '@whitespace' },
                // [[ attributes ]].
                [/\[\s*\[/, { token: 'annotation', next: '@annotation' }],
                // delimiters and operators
                [/[{}()\[\]]/, '@brackets'],
                [/[<>](?!@symbols)/, '@brackets'],
                [
                    /@symbols/,
                    {
                        cases: {
                            '@operators': 'delimiter',
                            '@default': ''
                        }
                    }
                ],
                // numbers
                [/\d*\d+[eE]([\-+]?\d+)?(@floatsuffix)/, 'number.float'],
                [/\d*\.\d+([eE][\-+]?\d+)?(@floatsuffix)/, 'number.float'],
                [/0[xX][0-9a-fA-F']*[0-9a-fA-F](@integersuffix)/, 'number.hex'],
                [/0[0-7']*[0-7](@integersuffix)/, 'number.octal'],
                [/0[bB][0-1']*[0-1](@integersuffix)/, 'number.binary'],
                [/\d[\d']*\d(@integersuffix)/, 'number'],
                [/\d(@integersuffix)/, 'number'],
                // delimiter: after number because of .\d floats
                [/[;,.]/, 'delimiter'],
                // strings
                [/"([^"\\]|\\.)*$/, 'string.invalid'],
                [/"/, 'string', '@string'],
                // characters
                [/'[^\\']'/, 'string'],
                [/(')(@escapes)(')/, ['string', 'string.escape', 'string']],
                [/'/, 'string.invalid']
            ],
            whitespace: [
                [/[ \t\r\n]+/, ''],
                [/\/\*\*(?!\/)/, 'comment.doc', '@doccomment'],
                [/\/\*/, 'comment', '@comment'],
                [/\/\/.*\\$/, 'comment', '@linecomment'],
                [/\/\/.*$/, 'comment']
            ],
            comment: [
                [/[^\/*]+/, 'comment'],
                [/\*\//, 'comment', '@pop'],
                [/[\/*]/, 'comment']
            ],
            //For use with continuous line comments
            linecomment: [
                [/.*[^\\]$/, 'comment', '@pop'],
                [/[^]+/, 'comment']
            ],
            //Identical copy of comment above, except for the addition of .doc
            doccomment: [
                [/[^\/*]+/, 'comment.doc'],
                [/\*\//, 'comment.doc', '@pop'],
                [/[\/*]/, 'comment.doc']
            ],
            string: [
                [/[^\\"]+/, 'string'],
                [/@escapes/, 'string.escape'],
                [/\\./, 'string.escape.invalid'],
                [/"/, 'string', '@pop']
            ],
            raw: [
                [
                    /(.*)(\))(?:([^ ()\\\t"]*))(\")/,
                    {
                        cases: {
                            '$3==$S2': [
                                'string.raw',
                                'string.raw.end',
                                'string.raw.end',
                                { token: 'string.raw.end', next: '@pop' }
                            ],
                            '@default': ['string.raw', 'string.raw', 'string.raw', 'string.raw']
                        }
                    }
                ],
                [/.*/, 'string.raw']
            ],
            annotation: [
                { include: '@whitespace' },
                [/using|alignas/, 'keyword'],
                [/[a-zA-Z0-9_]+/, 'annotation'],
                [/[,:]/, 'delimiter'],
                [/[()]/, '@brackets'],
                [/\]\s*\]/, { token: 'annotation', next: '@pop' }]
            ],
            include: [
                [
                    /(\s*)(<)([^<>]*)(>)/,
                    [
                        '',
                        'keyword.directive.include.begin',
                        'string.include.identifier',
                        { token: 'keyword.directive.include.end', next: '@pop' }
                    ]
                ],
                [
                    /(\s*)(")([^"]*)(")/,
                    [
                        '',
                        'keyword.directive.include.begin',
                        'string.include.identifier',
                        { token: 'keyword.directive.include.end', next: '@pop' }
                    ]
                ]
            ]
        }
    };
});

